<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/style.min.css">
    <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/extra.css">
  <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/font-awesome.min.css">
    <link type="text/css" rel="stylesheet" href="http://roy.red/theme/stylesheet/glslEditor.css">
    <script type="application/javascript" src="http://roy.red/theme/script/glslEditor.js"></script>
  <script type="text/javascript" src="http://roy.red/theme/script/GlslCanvas.js"></script>

    <link href="http://roy.red/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Roy.red Atom">



  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Roy Wiggins" />
<meta name="description" content="" />
<meta name="keywords" content="">
<meta property="og:site_name" content="Roy.red"/>
<meta property="og:title" content=""/>
<meta property="og:description" content=""/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://roy.red/drafts/-.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-04-11 21:27:31-07:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://roy.red/author/roy-wiggins.html">
<meta property="article:section" content="misc"/>
<meta property="og:image" content="">
  <title>Roy.red &ndash; </title>
</head>
<body>
  <aside>
    <div>
      <a href="http://roy.red">
        <img src="http://roy.red/theme/img/profile.png" alt="Roy's Blog" title="Roy's Blog">
      </a>
      <h1><a href="http://roy.red">Roy's Blog</a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="http://roy.red/pages/resources-.html#resources">Resources</a></li>
          <li><a href="http://roy.red/pages/resume-.html#resume">Resume</a></li>
          <li><a href="https://twitter.com/RoyWiggins" target="_blank">@RoyWiggins</a></li>
          <li><a href="./editor" target="_blank">Editor</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-@RoyWiggins" href="https://twitter.com/RoyWiggins" target="_blank"><i class="fa fa-@RoyWiggins"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id=""></h1>
    <p>Posted on Tue 11 April 2017 in <a href="http://roy.red/category/misc.html">misc</a></p>
  </header>
  <div>
    <p>Before we go onward, I want to fix things up a bit. So far I've been picking the circle that defines the inversive reflection by guess-and-check, and the disks they're generating are not the unit circle. The following code uses trigonometry to calculate the location of the inverting circle given the angles it needs to make with the axes, and the fact that it needs to be perpendicular to the unit circle. </p>
<div class="codeAndCanvas" literate data="void calcCircle(float theta, float phi,
                out vec2 cPos, out float r){
    float tanTheta = tan(PI/2. - theta);
    float tanTheta2 = tanTheta * tanTheta;
    float tanPhi2 = tan(phi) * tan(phi);
    cPos=sqrt(vec2(1.+tanTheta2,(1.+tanPhi2)*tanTheta2)
                /(-tanPhi2+tanTheta2)
        );
    r = sqrt((1.+tanPhi2)*(1.+tanTheta2)
             /(-tanPhi2 + tanTheta2)
        );
}
vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    vec3 color = drawCircle(pt,invCent,invRad);
    color *= smoothstep(1.01,1.0,length(pt));
    for (int i=0;i<9;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"></div>

<p>Next we "tip" the circle by inverting around a circle with radius <span class="math">\(1\)</span> centered on <span class="math">\((0,-1)\)</span>. The result is a picture of the Poincaré half plane.</p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    // Tipping
    pt.y-=.5;
    pt=cInverse(pt,vec2(0,-1),1.);
    vec3 color = drawCircle(pt,invCent,invRad);
    color *= smoothstep(1.01,1.0,length(pt));
    for (int i=0;i<9;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"></div>

<p>In the half-plane model, <em>dilating</em> the plane is actually an isometry, and if we pick the right constants you can see how it happens. This is a tiling, remember- and if we can scale one picture of it to obtain an identical one, we must have actually translated it. </p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    //Scaling
    pt *= pow(2.,mix(0.,-4.41,fract(u_time/10.)));
    pt.y-=.5;
    pt=cInverse(pt,vec2(0,-1),1.);
    vec3 color = vec3(1.);
    color *= smoothstep(1.0001,1.0,length(pt));
    for (int i=0;i<19;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.));
    return color;
}"></div>

<p>Now we can tip it back into a Poincaré disk, and the translational effect is more obvious.</p>
<div class="codeAndCanvas" literate data="vec2 translate(vec2 pt, float amt){
    pt=cInverse(pt,vec2(0,-1),1.);
    pt.y+=.5;
    //Scaling
    pt *= pow(2.,amt);
    pt.y-=.5;
    return cInverse(pt,vec2(0,-1),1.);
}

vec3 color(vec2 pt) {
    int n=0;vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    pt = translate(pt,mix(0.,-4.41,fract(u_time/10.)));
    vec3 color = vec3(1.);
    color *= smoothstep(1.0001,1.0,length(pt));
    for (int i=0;i<10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.));
    return color;
}"></div>

<p>Now we can rotate around arbitrary points:</p>
<div class="codeAndCanvas" literate data="vec2 rot(vec2 z,float t){
    return mat2(cos(t),-sin(t),sin(t),cos(t))*z;
}

vec3 color(vec2 pt) {
    int n=0;vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    pt = rot(pt,-PI/4.);
    pt = translate(pt,4.41/2.);
    pt = rot(pt,u_time/10.);
    pt = translate(pt,-4.41/2.);
    pt = rot(pt,PI/4.);
    vec3 color = vec3(1.);
    color *= smoothstep(1.0001,1.0,length(pt));
    for (int i=0;i<10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.));
    return color;
}"></div>

<p>And translate along arbitrary lines:</p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    pt = translate(pt,1.);
    pt = rot(pt,PI/3.);
    pt = translate(pt,4.41*fract(u_time/5.));
    vec3 color = vec3(1.);
    color *= smoothstep(1.0001,1.0,length(pt));
    for (int i=0;i<10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.));
    return color;
}"></div>

<p>There's another type of motion that exists, that doesn't really have a Euclidean equivalent. It's called horolation. It's a "rotation" around an ideal point (one at the edge of the disk). By analogy with ordinary rotation, it's defined as two successive reflections (inversions) across lines (circles) through the ideal point. But notice: lines through the ideal point at <span class="math">\((0,-1)\)</span> are transformed into vertical lines in the half-plane model! So all we need to do is translate in the half plane to perform a horolation.</p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    vec3 color = vec3(1.);
    color *= smoothstep(1.0001,1.0,length(pt));

    pt=cInverse(pt,vec2(0,-1),1.);
    pt.y+=.5;
    pt.x+= mod(u_time/10.,10e3);
    color *= smoothstep(0.,.1,abs(fract(pt.x)-.5)*2.);
    pt.y-=.5;
    pt=cInverse(pt,vec2(0,-1),1.);
    for (int i=0;i<12;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.));
    return color;
}"></div>

<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;vec2 invCent; float invRad;
    calcCircle(PI/8.,PI/8.,invCent,invRad);
    vec3 color = vec3(1.);

    for (int i=0;i<12;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.));
    return color;
}"></div>

<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt *= .1*pow(2.,mix(-9.,-2.,mod(u_time/10.,1.)));
    pt.y+=1.475209;
    pt *= .07;
    vec2 invCent=vec2(.901574,0.70); float invRad=.999999;
    pt=cInverse(pt,vec2(0.00,0.549),.7);

    vec3 color = vec3(1.);//drawCircle(pt,invCent,invRad);
    for (int i=0;i<26;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,.8,1.));
    return color;
}"></div>

<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    vec3 color=vec3(1);
    pt.y+=.5;
    pt=cInverse(pt,vec2(0.00,1.),1.);
    pt *= .75;

    vec2 invCent=vec2(0.909,1.); float invRad=1.122;
    color *= vec3(smoothstep(.751,.75,length(pt)));
    for (int i=0;i<10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"></div>

<div class="codeAndCanvas" literate data="vec2 T(vec2 z,vec2 a, vec2 b, vec2 c, vec2 d) {
    return cDiv(cMul(z,a)+b,cMul(z,c)+d);
}

void calcCircle(float theta, float phi, out vec2 cPos, out float r){
    float tanTheta = tan(PI/2. - theta);
    float tanPhi = tan(phi);
    float tanTheta2 = tanTheta * tanTheta;
    float tanPhi2 = tanPhi * tanPhi;
    cPos = sqrt(vec2(((1.+tanTheta2)),                ((1.+tanPhi2)*tanTheta2))/(-tanPhi2+tanTheta2));
    r = sqrt((1. + tanPhi2)*(1. + tanTheta2) /(-tanPhi2 + tanTheta2));
}

vec2 rot(vec2 z,float t){
    return mat2(cos(t),-sin(t),sin(t),cos(t))*z;
}
vec3 color(vec2 pt) {
    int n=0;
    vec3 color=vec3(1);
//    pt.y-=1.6;
//    pt *= .4;
    pt *= 1.1;

//    pt = T(pt,vec2(1,0),vec2(0,-1),vec2(0,-1),vec2(1,0));
//    pt *= pow(2.5,1.+fract(u_time/3.)*6.6);
    pt = T(pt,vec2(1,0),vec2(0,1),vec2(0,1),vec2(1,0));
//    pt = rot(pt,u_time);
    color *= vec3(smoothstep(1.0,.96,length(pt)));

    //    pt=cInverse(pt,vec2(0.00,1.),1.);

    vec2 invCent=vec2(0.90001,.9755); float invRad=1.1093;
    calcCircle(PI/4.,PI/5.,invCent,invRad);
    for (int i=0;i<9;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"></div>

<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
  <div class="tag-cloud">
    <p>
    </p>
  </div>
</article>

    <footer>
        <p>&copy; Roy Wiggins </p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "",
  "headline": "",
  "datePublished": "2017-04-11 21:27:31-07:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Roy Wiggins",
    "url": "http://roy.red/author/roy-wiggins.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "http://roy.red/drafts/-.html",
  "description": ""
}
</script>  
  <script type="application/javascript" src="http://roy.red/theme/script/main.js"></script>
</body>
</html>