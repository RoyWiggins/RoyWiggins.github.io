<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Roy.red</title><link href="http://roy.red/" rel="alternate"></link><link href="http://roy.red/feeds/all.atom.xml" rel="self"></link><id>http://roy.red/</id><updated>2018-01-06T13:27:09-08:00</updated><entry><title>Generating spherical and hyperbolic tilings in GLSL</title><link href="http://roy.red/generating-spherical-and-hyperbolic-tilings-in-glsl-.html" rel="alternate"></link><published>2018-01-06T13:27:09-08:00</published><updated>2018-01-06T13:27:09-08:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2018-01-06:generating-spherical-and-hyperbolic-tilings-in-glsl-.html</id><summary type="html">&lt;p&gt;In &lt;a href="//roy.red/folding-tilings-.html#folding-tilings"&gt;my previous post&lt;/a&gt;, I explored generating hyperbolic, euclidean and spherical tilings using circle inversions. While it produced interesting pictures and animations, I wasn't able to derive a formula to generate particular tilings. There's another way to generate tilings that admits a beautifully simple unification of the three geometries. We will need a bit more machinery, but the result is interesting and approaches the problem in a different way. This post is based nearly entirely on &lt;a href="https://www.shadertoy.com/view/4sf3zX"&gt;Knighty's shader&lt;/a&gt; with some help from notes the author left on fractalforums.&lt;/p&gt;
&lt;div style ="padding: .5em; border: 1px solid black; float:right; text-align: center; font-size: 0.8em; color:gray"&gt;
&lt;img style="float:right;" width="230px" src="http://roy.red/images/triangles.svg"/&gt;&lt;/a&gt;&lt;br/&gt;Triangles in different geometries&lt;/div&gt;

&lt;p&gt;To begin, we need to define the triangle that we are going to tile. A triangle can be defined by the angles  made at each vertex. In hyperbolic and spherical geometry, three angles are sufficient to define the triangle uniquely (you can't scale triangles without the internal angles also changing). A triangle can tile its geometry if (and only if) all three angles divide &lt;span class="math"&gt;\(2\pi\)&lt;/span&gt;. In other words, around each vertex, you can fit a whole number of triangle copies. The usual way to define a triangle is therefore to pick &lt;span class="math"&gt;\(p,q,r\)&lt;/span&gt; and set the internal angles to be &lt;span class="math"&gt;\(\frac{\pi}{p},\frac{\pi}{q}\)&lt;/span&gt; and &lt;span class="math"&gt;\(\frac{\pi}{r}\)&lt;/span&gt;. To tell if &lt;span class="math"&gt;\((p,q,r)\)&lt;/span&gt; describes a spherical, planar, or hyperbolic triangle, we compare the sum of the interior angles to &lt;span class="math"&gt;\(\pi\)&lt;/span&gt;: if it's less, it's hyperbolic; if greater, it's spherical. Since they all divide &lt;span class="math"&gt;\(\pi\)&lt;/span&gt;, you can simply compare &lt;span class="math"&gt;\(\frac{1}{p} + \frac{1}{q} + \frac{1}{r}\)&lt;/span&gt; to &lt;span class="math"&gt;\(1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The next thing we need to define is our &lt;em&gt;model&lt;/em&gt; of each geometry. Euclidean and spherical geometry both have natural models: the plane and the sphere. In the previous post, we mentioned the hyperboloid model on the way to working in the Poincar√© model, but here we are going to use the hyperboloid model directly. The sphere and plane are both familiar, but we have to inspect the hyperboloid model more closely to understand what's actually going on. &lt;/p&gt;
&lt;div style ="padding: .5em; border: 1px solid black; float:right; text-align: center; font-size: 0.8em; color:gray"&gt;
&lt;img style="float:right;" width="230px" src="http://roy.red/images/hyperboloid2.svg"/&gt;&lt;/a&gt;&lt;br/&gt;Hyperboloid&lt;/div&gt;

&lt;p&gt;The hyperboloid model lives on an infinitely large three-dimensional bowl shape. What you can't see in the diagram is that it doesn't live inside ordinary space at all. This space has a different metric, which means lengths and angles aren't measured quite the same. In ordinary 3D space, the dot product of two vectors &lt;span class="math"&gt;\(\vec{a} \cdot \vec{b}\)&lt;/span&gt;, &lt;span class="math"&gt;\(\vec{a}=\left\langle a_0,a_1,a_2\right\rangle,\vec{b}=\left\langle b_0,b_1,b_2\right \rangle\)&lt;/span&gt; is &lt;span class="math"&gt;\(a_0b_0+a_1b_1+a_2b_2\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;We can use the dot product to define the squared-magnitude (aka length squared) of a vector &lt;span class="math"&gt;\(\vec{a}\)&lt;/span&gt; :&lt;/p&gt;
&lt;div class="math"&gt;$$\vec{a} \cdot \vec{a} = a_0^2+a_1^2+a_1^2 = |\vec{a}|^2$$&lt;/div&gt;
&lt;p&gt;The hyperboloid model lives in a space where a different dot product applies:&lt;/p&gt;
&lt;div class="math"&gt;$$\vec{a} \cdot_{\tiny{H}} \vec{b} = a_0b_0+a_1b_1-a_2b_2$$&lt;/div&gt;
&lt;p&gt;If we use the dot product to define the magnitude-squared of &lt;span class="math"&gt;\(\vec{a}\)&lt;/span&gt;, we get a different magnitude than in ordinary space. In other words, distances behave differently here. 
&lt;/p&gt;
&lt;div class="math"&gt;$$|\vec{a}|^2 = a_0^2+a_1^2-a_1^2$$&lt;/div&gt;
&lt;div style ="padding: .5em; border: 1px solid black; float:right; text-align: center; font-size: 0.8em; color:gray"&gt;
&lt;img style="float:right;" width="130px" src="http://roy.red/images/hyperbola.png"/&gt;&lt;/a&gt;&lt;br/&gt;Hyperbola&lt;/div&gt;

&lt;p&gt;The equation for this hyperboloid is &lt;span class="math"&gt;\(x^2 + y^2 - z^2 = 1\)&lt;/span&gt;. Alternatively, you can define it as vectors &lt;span class="math"&gt;\(\vec{a}\)&lt;/span&gt; such that &lt;span class="math"&gt;\(\vec{a} \cdot_{\tiny{H}} \vec{a} = 1\)&lt;/span&gt;. In the ordinary 3-D Euclidean metric, &lt;span class="math"&gt;\(\vec{a} \cdot \vec{a} = 1\)&lt;/span&gt; is a unit sphere. So, this hyperboloid is a sort of "hyperbolic sphere"- it's this space's equivalent of a sphere, the set of all points a unit distance away from the origin. We can draw a 2D version of this easily. Notice that with &lt;code&gt;space = 0&lt;/code&gt;, it "degenerates" into two flat planes.&lt;/p&gt;
&lt;p&gt;It's important that we are actually flipping the surface so that the two halves of the hyperboloid open vertically up and down, and the Euclidean plane(s) are also in line with the &lt;span class="math"&gt;\(xy\)&lt;/span&gt; plane. It's points on these surfaces that behave like we want. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="// This is code is 'live'; adjust 'space'
float y = 0.;
float space = -1.; // try 0.0 or 1.0
float dot_(vec3 a, vec3 b) { 
    // Perform either dot product
    return a.x*b.x+a.y*b.y+space*a.z*b.z;
}
vec3 color(vec2 z) {
    // Draw the xz-plane
    vec3 z3 = 2.*vec3(z.x,y,z.y); 
    z3 = z3.zyx; // flip
    return vec3(dot_(z3,z3)&lt;0.9 ||
                dot_(z3,z3)&gt;1.1);
}"&gt;&lt;/div&gt;

&lt;p&gt;In the hyperboloid model of hyperbolic geometry, lines are the intersection of the hyperboloid with planes through the origin ("cutting planes"), which take the form of hyperbolas. These are akin to the great circles, which are lines in spherical geometry, and are &lt;em&gt;also&lt;/em&gt; intersections of the sphere with cutting planes. We can also identify lines in Euclidean geometry as intersections of cutting planes with a plane at &lt;span class="math"&gt;\(z=1\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;It's obvious that if you take a plane passing through the origin, it cuts the sphere in two identical pieces, and reflecting the sphere across the plane is an isometry: it doesn't change the sphere. This is also true for cutting planes and the hyperboloid... &lt;em&gt;if&lt;/em&gt; you reflect it using the hyperbolic dot product, rather than the Euclidean. &lt;/p&gt;
&lt;p&gt;First, we identify the plane with the normal vector &lt;span class="math"&gt;\(\vec{p}\)&lt;/span&gt;, which has a unit norm &lt;span class="math"&gt;\(\vec{p} \cdot \vec{p} = 1\)&lt;/span&gt;. To reflect a vector &lt;span class="math"&gt;\(\vec{a}\)&lt;/span&gt; across a plane with unit normal &lt;span class="math"&gt;\(\vec{p}\)&lt;/span&gt;, we can perform the following operation:&lt;/p&gt;
&lt;div class="math"&gt;$$\vec{a}' = \vec{a} - 2(\vec{a} \cdot \vec{p})\vec{p}$$&lt;/div&gt;
&lt;p&gt;It's easiest to see why this works in the Euclidean case. &lt;span class="math"&gt;\(\vec{a} \cdot \vec{p}\)&lt;/span&gt; is the distance from &lt;span class="math"&gt;\(\vec{a}\)&lt;/span&gt; (interpreted as a point) to the plane. &lt;span class="math"&gt;\(\vec{a} - (\vec{a} \cdot \vec{p})\vec{p}\)&lt;/span&gt; lies on the plane; subtracting again, and you're the same distance away on the other side of the plane. Importantly, this works exactly the same way with points on the vertical hyperboloid and the hyperbolic dot product. Reflecting the hyperboloid across a plane like this is an isometry, just like reflecting a sphere is. &lt;/p&gt;
&lt;p&gt;However, to make this work for euclidean tilings we are going to rewrite it in terms of the dot product only. To start, let's try it with the hyperbolic case. If we negate the &lt;span class="math"&gt;\(z\)&lt;/span&gt; coordinate of &lt;span class="math"&gt;\(\vec{p}\)&lt;/span&gt;, we can build a transformation that reflects properly (negating &lt;span class="math"&gt;\(z\)&lt;/span&gt; is "safe" because between the two arms of the hyperboloid, the problem is symmetrical).&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
\vec{p} &amp;amp;= \langle p_0,p_1,p_2 \rangle \\
\vec{q} &amp;amp;= \langle p_0,p_1,-p_2 \rangle \\
\vec{a}' &amp;amp;= \vec{a} - 2(\vec{a} \cdot_{\tiny{H}} \vec{p}) \vec{p} \\
\vec{a}' &amp;amp;= \vec{a} - 2( a_0p_0+a_1p_1-a_2p_2 ) \vec{p}  \\
\vec{a}' &amp;amp;= \vec{a} - 2( \vec{a} \cdot \vec{q} ) \vec{p} \\ 
\vec{a}' &amp;amp;= \vec{a} - 2( \vec{a} \cdot \vec{q} ) \vec{q} \langle1,1,-1\rangle
\end{align*}$$&lt;/div&gt;
&lt;p&gt;So for &lt;span class="math"&gt;\(k \in {1,-1}\)&lt;/span&gt; it's clear that &lt;span class="math"&gt;\(\vec{a} - 2( \vec{a} \cdot \vec{p} ) \vec{p} \langle1,1,k\rangle\)&lt;/span&gt; is the right transformation. But now if we set &lt;span class="math"&gt;\(k=0\)&lt;/span&gt;, it produces a reflection across the intersection of the cutting plane with the plane at &lt;span class="math"&gt;\(z=1\)&lt;/span&gt; (it definitely maps the plane to itself, because &lt;span class="math"&gt;\(z\)&lt;/span&gt; is unchanged). Strictly speaking, in the plane it is not quite an isometry: distances end up being scaled as well. &lt;/p&gt;
&lt;p&gt;Here it is in action in two dimensions. Switch to the ordinary space by setting &lt;code&gt;space = 1.&lt;/code&gt;. See what it does to the red region in each space as you adjust &lt;code&gt;p&lt;/code&gt;. Notice that the shape of the surface (circle, hyperboloid or plane) is preserved by the transformation. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="float space = -1.;
vec2 p = vec2(-0.460,-0.130);
// Calculate the length-squared of vector
float len2(vec2 a) {
    return a.x*a.x + space*a.y*a.y;
}
vec3 color(vec2 a) {
    a *= 2.; vec3 c = vec3(1);
    // Normalize so len(p)=1
    p /= sqrt(len2(p));
    // Reflect the world
    a = a - 2.*dot(a,p)*p*vec2(1,space);
    // Draw the cutting plane
    c.rg = vec2(abs(dot(a,p))&gt;.05);
    // Draw the plane normal vector
    c.rb -= float(abs(dot(a,vec2(-p.y,p.x)))&lt;.03 
            &amp;&amp; dot(a,p)&lt;0. &amp;&amp; dot(a,a)&lt;.2);
    // Draw the surface
    c -= vec3(abs(len2(a.yx)-1.)&lt;0.1)
    // Draw the red region
        *vec3(1.-(1.-abs(a.x))*float(a.y&gt;0.),1,1);
    return c;
}"&gt;&lt;/div&gt;

&lt;p&gt;So. Now we know how to reflect in our geometries. Now, we need to work out what planes to reflect across.&lt;/p&gt;
&lt;p&gt;If two cutting planes intersect with angle &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, the angle the associated great circles make on the sphere is clearly also &lt;span class="math"&gt;\(\theta\)&lt;/span&gt;, because the planes are always perpendicular to the sphere. This is also true for the angle between two planes and the angle between their associated hyperbolas on the hyperboloid: the cutting planes are actually perpendicular to the hyperboloid, if you measure using the hyperbolic dot product. You can define angles between two cutting planes by the dot product of their respective normal vectors:&lt;/p&gt;
&lt;div class="math"&gt;$$\cos{\theta} = |\vec{a}||\vec{b}| \vec{a} \cdot \vec{b}$$&lt;/div&gt;
&lt;p&gt;This also applies with the hyperbolic dot product, but angles (like distances) stop being exactly what they look like. &lt;/p&gt;
&lt;p&gt;So, the problem of finding triangles with a particular &lt;span class="math"&gt;\((p,q,r)\)&lt;/span&gt; is the same as finding three vectors &lt;span class="math"&gt;\(\vec{a}, \vec{b}, \vec{c}\)&lt;/span&gt; that define cutting planes that make the correct angles with each other, measured in the correct metric. So:&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
\vec{a} \cdot \vec{b} &amp;amp; = -\cos{\frac{\pi}{p}}\\
\vec{a} \cdot \vec{c} &amp;amp; = -\cos{\frac{\pi}{q}}\\
\vec{c} \cdot \vec{b} &amp;amp; = -\cos{\frac{\pi}{r}}
\end{align*}$$&lt;/div&gt;
&lt;p&gt;Choose &lt;span class="math"&gt;\(\vec{a}\)&lt;/span&gt; and &lt;span class="math"&gt;\(\vec{b}\)&lt;/span&gt; to lie in the &lt;span class="math"&gt;\(xy\)&lt;/span&gt; plane making angle &lt;span class="math"&gt;\(\frac{\pi}{p}\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
\vec{a} &amp;amp;= \left\langle1,0,0\right\rangle\\
\vec{b} &amp;amp;= \left\langle -\cos{\frac{\pi}{p}},\sin{\frac{\pi}{p}},0\right\rangle
\end{align*}$$&lt;/div&gt;
&lt;p&gt;Notice that &lt;span class="math"&gt;\(a_2=0\)&lt;/span&gt; so, regardless of metric,&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
\vec{a} \cdot \vec{c} &amp;amp;= a_0 c_0 +a_1c_1\\
&amp;amp;= c_0
\end{align*}$$&lt;/div&gt;
&lt;p&gt;Next we solve for &lt;span class="math"&gt;\(c_1\)&lt;/span&gt;. &lt;span class="math"&gt;\(b_2=0\)&lt;/span&gt; so &lt;span class="math"&gt;\(\vec{b} \cdot \vec{c}\)&lt;/span&gt; is simply (again, regardless of metric):&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
\vec{b} \cdot \vec{c} &amp;amp;= b_0 c_0 +b_1c_1\\
c_1&amp;amp;=\frac{\vec{b}\cdot \vec{c} -b_0c_0}{b_1}\\
\end{align*}$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\vec{c}\)&lt;/span&gt; must be a unit vector, so &lt;span class="math"&gt;\(\vec{c} \cdot \vec{c} = 1\)&lt;/span&gt;. But, we don't know what metric we're in, so we parametrize it with &lt;span class="math"&gt;\(k\in\{-1,0,1\}\)&lt;/span&gt;.
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
1&amp;amp;=c_0^2+c_1^2+kc_2^2\\
k{c_2}^2 &amp;amp;= 1-c_0^2-c_1^2\\
\left|k{c_2}^2\right| &amp;amp;= \left|1-c_0^2-c_1^2\right|\\
c_2 &amp;amp;= \sqrt{\left|1-c_0^2-c_1^2\right|}
\end{align*}$$&lt;/div&gt;
&lt;p&gt;We picked the positive square root for &lt;span class="math"&gt;\(c_2\)&lt;/span&gt;, which is an arbitrary choice in the Euclidean case but in the hyperbolic case, there are actually two arms of the hyperbola (one pointing up, the other down). We want to build the tiling in the upper one and this choice does that for us.&lt;/p&gt;
&lt;p&gt;The parameter &lt;span class="math"&gt;\(k\)&lt;/span&gt; has fallen away, so we actually have a formula that works for either hyperbolic or spherical triangles. For Euclidean ones, &lt;span class="math"&gt;\(k=0\)&lt;/span&gt; so &lt;span class="math"&gt;\(c_2\)&lt;/span&gt; can be any constant, and it just acts like a scaling factor. &lt;/p&gt;
&lt;p&gt;We can now substitute back in the dot products, to get the final values for the components of &lt;span class="math"&gt;\(\vec{c}\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
c_0 &amp;amp;= -\cos{\frac{\pi}{q}}\\
c_1 &amp;amp;= \frac{ -\cos{\frac{\pi}{q}} -\cos{\frac{\pi}{p}}\cos{\frac{\pi}{r}}}{\sin{\frac{\pi}{p}}}\\
c_2 &amp;amp;= \sqrt{\left|\sin^2{\frac{\pi}{r}}-c_1^2\right|}\\
\end{align*}$$&lt;/div&gt;
&lt;p&gt;The last thing we need is an equation to project points in the plane to points on the hyperbola or sphere. There are a few choices, but we're going to use a stereographic projection. The idea is to draw a line between &lt;span class="math"&gt;\((0,0,-1)\)&lt;/span&gt; and a point on the surface, and map that point to the intersection of line with the plane at &lt;span class="math"&gt;\(z=0\)&lt;/span&gt;. &lt;/p&gt;
&lt;p&gt;We are going to work in two dimensions to make the algebra much easier. The surfaces have rotational symmetry around the &lt;span class="math"&gt;\(z\)&lt;/span&gt; axis, so we can work in &lt;span class="math"&gt;\((r,z)\)&lt;/span&gt; coordinates. &lt;span class="math"&gt;\(r\)&lt;/span&gt; is the distance away from the &lt;span class="math"&gt;\(z\)&lt;/span&gt; axis and corresponds to the &lt;span class="math"&gt;\(x\)&lt;/span&gt; dimension. &lt;/p&gt;
&lt;div class="math"&gt;$$r,z \mapsto \left( R,Z \right) = \left( \frac{r}{1+z},0\right) $$&lt;/div&gt;
&lt;p&gt;We need to invert the transformation to take the plane to the surfaces. We can define the surfaces like this:&lt;/p&gt;
&lt;div class="math"&gt;$$z^2 + kr^2 = 1, k \in \left(-1,0,1\right)$$&lt;/div&gt;
&lt;p&gt;So, we start with &lt;span class="math"&gt;\(\frac{r}{1+z}\)&lt;/span&gt;, square it, substitute in and solve for &lt;span class="math"&gt;\(z\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
R^2 &amp;amp;= \frac{r^2}{(1+z)^2}\\ 
&amp;amp;= \frac{1}{k} \frac{1-z^2}{(1+z)^2} = k \frac{(1+z)(1-z)}{(1+z)^2}\\
&amp;amp;= k \frac{1-z}{1+z}  \\
R^2 (1+z) &amp;amp;= k (1-z)  \\
R^2 + R^2 z &amp;amp;= k - kz \\
R^2 z + kz &amp;amp;= k - R^2 \\
z &amp;amp;= \frac{k - R^2}{k + R^2} = \frac{k - R^2}{k + R^2} \frac{k}{k}\\
\therefore z &amp;amp;= \frac{1 - kR^2}{1 + kR^2}
\end{align*}$$&lt;/div&gt;
&lt;p&gt;And we can now solve for &lt;span class="math"&gt;\(r\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{align*}
R &amp;amp;= \frac{r}{1+z} \\
r &amp;amp;= \left(1+z\right) R \\
r &amp;amp;= \left(1+\frac{1-kR^2}{1+kR^2}\right) R \\
r &amp;amp;= \left(\frac{1+kR^2}{1+kR^2}+\frac{1-kR^2}{1+kR^2}\right) R \\
\therefore r &amp;amp;= \frac{2R}{1+kR^2}
\end{align*}$$&lt;/div&gt;
&lt;p&gt;So the transformation is &lt;/p&gt;
&lt;div class="math"&gt;$$ R \mapsto \left(\frac{2R}{1+kR^2}, \frac{1 - kR^2}{1 + kR^2},\right)$$&lt;/div&gt;
&lt;p&gt;We can pull this into two dimensions easily. &lt;span class="math"&gt;\(R^2 = X^2+Y^2\)&lt;/span&gt;, and doubling &lt;span class="math"&gt;\(R\)&lt;/span&gt; doubles both &lt;span class="math"&gt;\(X\)&lt;/span&gt; and &lt;span class="math"&gt;\(Y\)&lt;/span&gt;, so the final function looks like:&lt;/p&gt;
&lt;div class="math"&gt;$$ \left(X,Y\right) \mapsto \left(\frac{2X}{1+k\left(X^2+Y^2\right)}, \frac{2Y}{1+k\left(X^2+Y^2\right)}, \frac{1-k\left(X^2+Y^2\right)}{1+k\left(X^2+Y^2\right)}\right)$$&lt;/div&gt;
&lt;p&gt;Pulling this all together, and out pops the tilings we want. Adjust &lt;code&gt;p,q,r&lt;/code&gt; to see how they behave.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="// Adjust p, q, r
float p = 3.; float q=4.; float r=3.;
float space = float(sign(q*r+p*r+p*q-p*q*r));
vec3 fold( vec3 p, in vec3 dir, inout int n) {
// Reflect if we're outside the fundamental region
    float dt = dot(p,dir);
    if (dt &lt; 0.) {
        n = n + 1;
        return p-2.*dt*dir*vec3(1,1,space);
    }
    return p;
}
vec3 color(vec2 z) {
    // Stereographically project
    vec3 w=vec3(2.*z,1.-space*dot(z,z))*1./(1.+space*dot(z,z));
    // Calculate cutting planes
    float ab = -cos(PI/p);
    float bc = -cos(PI/q);
    float ac = -cos(PI/r);
    vec3 a = vec3(1,0,0);
    vec3 b = vec3(ab,sin(PI/p),0.);
    float c0 = ac;
    float c1 = (bc-b[0]*c0)/b[1];
    vec3 c = vec3(c0,c1,sqrt(abs(1.-c0*c0-c1*c1)));
    if (space==0.)
        c[2] = .5;

    // Fold across the planes a few times
    int n=0; int m = 0;
    for (int i=0;i&lt;10;i++){
        w = fold(w,a,m);
        w = fold(w,b,m);
        w = fold(w,c,n);
    }
    // Return a color based on where you end up
    return vec3(2.)*(dot(w,a));
}"&gt;&lt;/div&gt;

&lt;p&gt;In the hyperbolic case, we can investigate other projections, such as just pulling the point in the plane up to the hyperboloid:&lt;/p&gt;
&lt;div class="codeAndCanvas" pre="float p = 3.; float q=4.; float r=3.;
float space = float(sign(q*r+p*r+p*q-p*q*r));
vec3 fold( vec3 p, in vec3 dir, inout int n) {
    float dt = dot(p,dir);
    if (dt &lt; 0.) {
        n = n + 1;
        return p-2.*dt*dir*vec3(1,1,space);
    }
    return p;
}
vec3 calc(vec3 w){
    // Calculate cutting planes
    float ab = -cos(PI/p);
    float bc = -cos(PI/q);
    float ac = -cos(PI/r);
    vec3 a = vec3(1,0,0);
    vec3 b = vec3(ab,sin(PI/p),0.);
    float c0 = ac;
    float c1 = (bc-b[0]*c0)/b[1];
    vec3 c = vec3(c0,c1,sqrt(abs(1.-c0*c0-c1*c1)));
    if (space==0.)
        c[2] = .5;

    // Fold across the planes a few times
    int n=0; int m = 0;
    for (int i=0;i&lt;10;i++){
        w = fold(w,a,m);
        w = fold(w,b,m);
        w = fold(w,c,n);
    }
    // Return a color based on where you end up
    return vec3(2.)*(dot(w,a));
}" data="vec3 color(vec2 z) {
    z *= 20.;
    vec3 w=vec3(z,sqrt(1.+dot(z,z)));
    // Calculate the tiling
    return calc(w);
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;We can also apply a &lt;a href="http://www.physicsinsights.org/hyperbolic_rotations.html"&gt;hyperbolic rotation&lt;/a&gt; to the hyperbolic tiling, which acts like a translation along the hyperboloid.  &lt;/p&gt;
&lt;div class="codeAndCanvas" pre="float p = 4.; float q=5.; float r=2.;
float space = float(sign(q*r+p*r+p*q-p*q*r));
vec3 fold( vec3 p, in vec3 dir, inout int n) {
    float dt = dot(p,dir);
    if (dt &lt; 0.) {
        n = n + 1;
        return p-2.*dt*dir*vec3(1,1,space);
    }
    return p;
}
vec3 calc(vec3 w){
    float ab = -cos(PI/p);
    float bc = -cos(PI/q);
    float ac = -cos(PI/r);
    int n=0; int m = 0;
    vec3 a = vec3(1,0,0);
    vec3 b = vec3(ab,sin(PI/p),0.);
    float c0 = ac;
    float c1 = (bc-b[0]*c0)/b[1];
    vec3 c = vec3(c0,c1,sqrt(abs(1.-c0*c0-c1*c1)));

    if (space==0.)
        c[2] = .5;

    for (int i=0;i&lt;10;i++){
        w = fold(w,a,m);
        w = fold(w,b,m);
        w = fold(w,c,n);
    }
    return vec3(2.)*(dot(w,a));
}" data="vec3 color(vec2 z) {
    vec3 w = vec3(2.*z,1.-space*dot(z,z))*1./(1.+space*dot(z,z));
    // Apply hyperbolic rotation
    float angle = mod(u_time,1.05);
    w.xz = w.xz * mat2(cosh(angle),sinh(angle),
                       sinh(angle),cosh(angle)); 
    return calc(w);
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;That's all for now. This is a lot more laborious than just inverting across circles, but being able to mostly avoid trigonometry has an appeal all its own, I think!&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Folding Animated Hyperbolic &amp; Spherical Tilings</title><link href="http://roy.red/folding-tilings-.html" rel="alternate"></link><published>2017-04-12T15:46:52-07:00</published><updated>2017-04-12T15:46:52-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2017-04-12:folding-tilings-.html</id><summary type="html">&lt;p&gt;In a &lt;a href="/folding-the-koch-snowflake-.html#folding-the-koch-snowflake"&gt;previous post&lt;/a&gt;, I talked about generating interesting pictures by iterated folding operations. In this post I'm going to use another type of fold to draw both hyperbolic and spherical tilings. If you are already familiar with hyperbolic geometry and tilings, skip the next few paragraphs! There's code down at the bottom.&lt;/p&gt;
&lt;p&gt;In order to simplify what we're talking about, we can limit ourselves to tilings of right-angled triangles. In the Euclidean plane, there are two ways to tile the plane this way. One can be identified with a regular tiling of squares, and the other with a regular tiling of hexagons (or equilateral triangles). &lt;/p&gt;
&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;
&lt;a href="https://en.wikipedia.org/wiki/Spherical_polyhedron#/media/File:Spherical_pentakis_dodecahedron.png"&gt;&lt;img style="float:right;" width="200px" src="http://roy.red/images/spherical-dodecahedron.png"/&gt;&lt;/a&gt;&lt;br/&gt;A dodecahedral tiling&lt;/div&gt;

&lt;p&gt;There are no other ways to tile the plane like this. But instead of tiling the Euclidean plane, we can look toward other geometries. One you are probably familiar with is spherical geometry: instead of drawing lines on a flat plane, we draw arcs on a sphere. Inside the spherical geometry, portions of &lt;a href="https://en.wikipedia.org/wiki/Great_circle"&gt;great circles&lt;/a&gt; are actually straight lines. While things look a bit different, you can still build right triangles, and tile the sphere with them. On the sphere, there are few &lt;a href="https://en.wikipedia.org/wiki/Spherical_polyhedron"&gt;more tilings&lt;/a&gt;! &lt;/p&gt;
&lt;p&gt;In a sense, the spherical geometry is bending every straight line a bit towards every other straight line. If you extend a line segment, it will intersect every other line, "around the back" of the sphere. You can convince yourself of this with some patient time with a globe.&lt;/p&gt;
&lt;hr style="clear:right;"/&gt;

&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;
&lt;a href="https://upload.wikimedia.org/wikipedia/commons/f/f3/Hyperboloid-2s.svg"&gt;&lt;img style="float:right;" src="http://roy.red/images/hyperboloid.svg" height="200px"/&gt;&lt;/a&gt;&lt;br/&gt;Two views of a hyperboloid&lt;/div&gt;

&lt;p&gt;There's another geometry that goes in the "other direction": it bends every straight line away from every other. This is the mysterious &lt;a href="https://en.wikipedia.org/wiki/Hyperbolic_geometry"&gt;hyperbolic geometry&lt;/a&gt;. It's called hyperbolic by analogy to the spherical geometry: you can draw lines as parts of hyperbolas, on one sheet of a hyperboloid.&lt;/p&gt;
&lt;p&gt;In this geometry, there are even more tilings (an infinite number, in fact). You can fit as many identical right triangles around a vertex as you like, and the resulting polygon can tile the plane. There is, in a sense, "more space" to move around in. If you draw two straight lines, they may intersect- but they might not intersect at all, no matter how far you extend them. There's 'more' space for the lines to go, and they tend to bend away from each other.&lt;/p&gt;
&lt;p&gt;While these geometries both "live" in three-dimensional objects (spheres and hyperboloids) they can be modeled in the plane. In the case of spherical geometry, you can simply &lt;a href="https://en.wikipedia.org/wiki/Stereographic_projection"&gt;stereographically project&lt;/a&gt; the sphere onto the plane. Straight lines (arcs) on the sphere become circles in the plane. Further away from the origin, objects look bigger (even if they're the same size on the sphere). &lt;/p&gt;
&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;&lt;a href="
https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model#/media/File:HyperboloidProjection.png
"&gt;&lt;img src="http://roy.red/images/poincare-projection.png" height="200px"/&gt;&lt;/a&gt;&lt;br/&gt;Poincar√© projection&lt;/div&gt;

&lt;p&gt;The model we are using of hyperbolic geometry is called the Poincar√© Disk. It gathers the entirety of the hyperbolic space into a circle in the plane. It is formed similarly to the stereographic projection: it projects points on the hyperboloid down onto the plane by casting a ray from a point underneath.&lt;/p&gt;
&lt;div style="clear:right;"/&gt;
&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;&lt;a href="https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model#/media/File:Droites_disquePoincar√©.svg"&gt;&lt;img src="http://roy.red/images/poincare.svg" height="200px"/&gt;&lt;/a&gt;&lt;br/&gt;Three hyperbolic lines&lt;/div&gt;

Straight lines (hyperbolas) in the hyperbolic geometry are drawn as circles in the plane. Further away from the origin (and closer to the edge of the disk), objects look smaller (even though they're the same size on the hyperboloid). Angles are preserved, so (for instance) two lines that appear to be perpendicular when measured by Euclidean standards actually are perpendicular. 

&lt;hr style="clear:right;"/&gt;

Okay. Long-winded math over, let's start folding things. Like the previous post, we're going to be mirroring pixels across a boundary. In this case, we are going to keep track of the number of times each point is actually moved by a folding operation. If a point is folded, we increment a variable; once we're done, we use the value to color the pixel.
&lt;br/&gt;&lt;br/&gt;
To begin, we do two folds across the X and Y axes. You can adjust the orientation of the fold axes to see how it behaves. The upper-right quadrant stays black because points there are never moved. Points in the lower left are folded twice, and so are also black. The other two are folded exactly once, so they turn gray.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="void fold(inout vec2 p, vec2 dir,inout int n){
    float dt = dot(p,dir);
    if (dt&lt;0.) {
        p-=2.*dt*dir;
        n++;
    }
}
vec3 color(vec2 pt) {
    int n=0;
    fold(pt,normalize(vec2(1,0)),n);
    fold(pt,normalize(vec2(0,1)),n);
    return vec3(fract(float(n)/2.));
}"&gt;&lt;/div&gt;

In the Poincar√© disk model of hyperbolic geometry, a straight line is drawn as a portion of a generalized circle (generalized, because the center of the circle can be "at infinity", and it looks like a line through the origin). To reflect across a hyperbolic line you actually invert across the circle. Inside the hyperbolic geometry, distances aren't affected by inversion, even if they look like they are in our model. So, using the circle inversion idea, we define a fold "across" a circle. If a point is outside the circle, it is unaffected, but if it is inside, it is "folded" to the outside with a circle inversion.
&lt;br/&gt;&lt;br/&gt;
Here, we are folding across two lines and a circle. From the point of view of the Poincar√© model, all three folds are across straight lines (or, alternatively, there are three circle inversions, and two of the circles have a center at infinity). You could do this with three suitably chosen circles, too.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="vec2 cInverse(vec2 z, vec2 center, float radius){
    z -= center;
    return z*radius*radius/dot(z,z) + center;
}
void fold_circle(inout vec2 z, vec2 c, float r, inout int n) {
    if (distance(z,c)&gt;r) return;
    z = cInverse(z,c,r);
    n++;
}
vec3 drawCircle(vec2 z,vec2 c,float r) {
    return vec3(smoothstep(distance(z,c)-r,.01,0.));
}
vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent=vec2(1); float invRad=1.122;
    vec3 color = drawCircle(pt,invCent,invRad);
    fold(pt,vec2(1,0),n);
    fold(pt,vec2(0,1),n);
    fold_circle(pt,invCent,invRad,n);
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;

Now if we just apply the folds a few more times, a new picture starts to emerge: it's a Poincar√© disk! These three folds are actually generating a hyperbolic geometry. Adjust the number of iterations to see how the circle inversions successively copy and smoosh the shapes into a steady progression towards the perimeter. These shapes are all right triangles, and they are all the same shape and size.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="void doFolds(inout vec2 z,vec2 c,float r,inout int n) {              
    fold(z,vec2(1,0),n);
    fold(z,vec2(0,1),n);
    fold_circle(z,c,r,n);
}
vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent=vec2(1); float invRad=1.122;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;

In the Poincar√© disk model, not every arc is a straight line: it has to be perpendicular to the edge of the disk. So you'll notice that as you move the inverting circle, the generated disk shifts and changes shape. With some more math, you can work back from the disk to find circles that will generate it. Many choices of circle don't result in a uniform tiling at all. More math can tame this as well, and generate tilings based on how many tiles should fit around each vertex. 
&lt;br/&gt;&lt;br/&gt;
You might have noticed that the picture changes quite a lot if the inverting circle actually includes the origin. The tiling suddenly doesn't approach a limit: it fills the entire plane with a finite number of tiles. The geometric reason is simply that, if you start inside a circle, the inversion will make the tile bigger and bigger, rather than smaller and smaller (like it did when the origin was outside the circle). The result here is actually a model of spherical geometry, and we've generated a tiling of the sphere. Conveniently, reflections in spherical geometry are also modeled by circle inversions in the plane.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt *= 2.;
    vec2 invCent=vec2(1); float invRad=2.00;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;3;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

When the origin is exactly on the circumference of the circle, we get a third case. There are an infinite number of tiles, but unlike the hyperbolic case, they march towards the origin. This looks pretty unfamiliar. It's definitely not spherical, and it doesn't look much like the hyperbolic pictures we had either. 

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent=vec2(sqrt(.5)); float invRad=1.;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

Surprise! It's actually a circle inverted flat tiling. If we invert our coordinate system, we can recover a flat tiling. Remember than this was generated by inverting around a circle with a circumference that intersected the origin. Circles through the origin are straight lines under circle inversion, and vice versa, so that's why iterating the inversion through our circle generated the inverse of a flat tiling. So an ordinary reflection across a line can be thought of as a special case of an inversion across a circle.

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt = cInverse(pt*3.,vec2(0),1.);
    vec2 invCent=vec2(sqrt(.5)); float invRad=1.;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

Now for the magic bit: we can wobble our circle back and forth to generate all three types of tiling! From this perspective, flat Euclidean geometry can be seen quite naturally as sitting on the knife-edge between spherical and hyperbolic.  It transitions between &lt;a href="https://en.wikipedia.org/wiki/Orbifold_notation#/media/File:H2checkers_245.png"&gt;[4,5]&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Tetrakis_square_tiling#Symmetry"&gt;[4,4]&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Octahedral_symmetry"&gt;[4,3]&lt;/a&gt; tilings (in &lt;a href="https://en.wikipedia.org/wiki/Coxeter_notation"&gt;Coxeter notation&lt;/a&gt;).

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt = cInverse(pt*3.,vec2(0),1.);
    vec2 invCent=vec2(sqrt(.5));
    invCent.x += mix(-0.054,0.1,sin(u_time));
    float invRad=1.;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

You can do the same with the other flat tiling; here,  it transitions between &lt;a href="https://en.wikipedia.org/wiki/Icosahedral_symmetry"&gt;[5,3]&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Orbifold_notation#/media/File:Tile_V46b.svg"&gt;[6,3]&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/3-7_kisrhombille#Symmetry"&gt;[7,3]&lt;/a&gt; tilings.

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt = cInverse(pt*4.5,vec2(0),1.);
    vec2 invCent=vec2(sqrt(3.)/2.,.5);
    invCent.x += mix(-0.011,0.035,sin(u_time));
    float invRad=1.;
    for (int i=0;i&lt;20;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    return hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;


That's all for now. In my next post I will explore translating, rotating, and generally splashing about inside hyperbolic geometry. In the meantime, feel free to play with hyperbolic tilings &lt;a href="http://roy.red/editor/#../shaders/poincare-disk-fold.frag"&gt;in the editor here&lt;/a&gt;. If you want to play with a more fully-featured environment, I recommend this &lt;a href="http://gratrix.net/tile/tile.html"&gt;tiling generator&lt;/a&gt;.</summary></entry><entry><title>3D Kaleidoscopic Fractals: Folding the Koch Snowflake</title><link href="http://roy.red/folding-the-koch-snowflake-.html" rel="alternate"></link><published>2017-01-03T17:34:06-08:00</published><updated>2017-01-03T17:34:06-08:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2017-01-03:folding-the-koch-snowflake-.html</id><summary type="html">&lt;p&gt;I came across a shader that generated a &lt;a href="https://www.shadertoy.com/view/XdcGzH"&gt;very pretty version&lt;/a&gt; of the Koch snowflake](https://en.wikipedia.org/wiki/Koch_snowflake). I realized that after stepping through the code that the Koch snowflake is a good, simple example of generating fractals with folds. The code here is in the form of fragment shaders. For a shader primer, check out the &lt;a href="http://thebookofshaders.com/"&gt;Book of Shaders&lt;/a&gt;. The important thing is that to write a fragment shader, you build a function that takes a location (in our case, of a pixel) and returns a color. All the code here is "live", though changes you make in each box will not cascade down to the subsequent ones.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://acko.net/blog/how-to-fold-a-julia-fractal/"&gt;&lt;img style="float: right;" width="300" src="http://roy.red/images/julia-iter.gif"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Generating the Koch curve this way is probably among the simplest examples of how fractals can be thought of as a repeated crumpling of space. The animation to the right is borrowed from &lt;a href="http://acko.net/blog/how-to-fold-a-julia-fractal/"&gt;a presentation&lt;/a&gt; by Steven Wittens that ably demonstrates this with a Julia fractal: squishing, translating and folding space progressively crumples up the boundary of the unit circle.&lt;/p&gt;
&lt;p&gt;For the Koch curve, we need a different sort of fold. It's easiest to understand the folding operation visually. I haven't taken the time to justify this formula, but it's just trigonometry. You can adjust the angle to see how it creates a kaleidoscopic effect, reflecting the plane across a line through the origin. &lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;div class="codeAndCanvas" literate data="vec2 fold(vec2 p, float ang){
    vec2 n=vec2(cos(-ang),sin(-ang));
    p-=2.*min(0.,dot(p,n))*n;
    return p;
}
vec3 color(vec2 pt) {
    // Adjust the angle of the fold here
    pt=fold(pt,0.284);
    return vec3(10.*sin(10.*pt.x)*sin(10.*pt.y));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;Now we are going to start drawing a line. This formula calculates the distance to a line segment between &lt;span class="math"&gt;\((0,0)\)&lt;/span&gt; and &lt;span class="math"&gt;\((1,0)\)&lt;/span&gt;. This is the line we're going to fold up into a Koch curve.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="float d2hline(vec2 p){
    p.x-=max(0.,min(1.,p.x));
    return length(p)*5.;
}
vec3 color(vec2 pt) {
    pt=pt*2.;
    return vec3(d2hline(pt));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;There are two folds: first, across the angle &lt;span class="math"&gt;\(\frac{\pi}{6}\)&lt;/span&gt;, and then horizontally. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="
vec2 koch_fold(vec2 pt) {
    // Fold horizontally
    pt.x = abs(pt.x);
    pt.x-=.5;
    //Fold across PI/6
    pt = fold(pt,PI/6.);
    return pt;
}
vec3 color(vec2 pt) {
    pt*=2.;
    pt=koch_fold(pt);
    return vec3(d2hline(pt));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;We can iterate by moving and scaling the folded line to lie along the original line (from &lt;span class="math"&gt;\((0,0)\)&lt;/span&gt; to &lt;span class="math"&gt;\((0,1)\)&lt;/span&gt;) and then folding the line up again.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    pt*=2.;
    pt=koch_fold(pt); // Fold again
    // Move it to lie along the (0,1) line
    pt*=3.;
    pt.x-=1.5;
    pt=koch_fold(pt); // Fold once
    return vec3(d2hline(pt));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;And we can iterate this as many times as we'd like. It converges very rapidly, so you only need a handful of folds.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec2 koch_curve(vec2 pt) {
    //Fold and scale a few times
    for(int i=0;i&lt;5;i++){
        pt*=3.;
        pt.x-=1.5;
        pt=koch_fold(pt);
    }
    return pt;
}
vec3 color(vec2 pt) {
    pt = pt*.5+.5;
    pt = koch_curve(pt);
    return vec3(d2hline(pt)/5.);
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;And just for fun, we can do two more folds to create two copies of the curve to create the Koch Snowflake. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    pt = pt*.7;
    pt -= vec2(.5,.3);
    pt = fold(pt,-2.*PI/3.);
    pt.x += 1.;
    pt = fold(pt,-PI/3.);
    pt = koch_curve(pt);
    return vec3(d2hline(pt)/5.);
}"&gt;&lt;/div&gt;

&lt;p&gt;A small adjustment and we get another familiar fractal, a Sierpinski triangle, or close enough. I recommend you adjust the number of iterations to get a feel for how it converges.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="
vec2 tri_fold(vec2 pt) {
    pt = fold(pt,PI/6.);
    pt = fold(pt,-PI/6.);
    return pt;
}
vec2 tri_curve(vec2 pt) {
    for(int i=0;i&lt;7;i++){
        pt*=2.;
        pt.x-=1.;
        pt=tri_fold(pt);
    }
    return pt;
}
vec3 color(vec2 pt) {
    pt -= vec2(-1,.1);
    pt *= .5;
    pt = tri_curve(pt);
    return vec3(d2hline(pt)/7.);
}"&gt;&lt;/div&gt;

&lt;p&gt;You might have worked this out already: I've been keeping something from you. The real motivation here is to justify a wider class of fractals, dubbed Kaleidoscopic Iterated Function Systems, or KIFS. KIFS are what you get when you start folding and scaling around different axes. A myriad of fractals fall out, and you can see why they're called Kaleidoscopic- for the mirroring folds they're built out of. Here's an example. These reward fiddling: adjust the parameters to get a slightly better sense of how the folds affect the final output. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec2 gen_fold(vec2 pt) {
    pt = fold(pt,-2.9);
    pt = fold(pt,.9);
    pt.y+=sin(u_time)+1.;
    pt = fold(pt,-1.0);
    return pt;
}
vec2 gen_curve(vec2 pt) {
    for(int i=0;i&lt;9;i++){
        pt*=2.;
        pt.x-=1.;
        pt=gen_fold(pt);
    }
    return pt;
}
vec3 color(vec2 pt) {
    pt -= vec2(-0.630,0.000);
    pt *= .8;
    pt = gen_curve(pt);
    return vec3(d2hline(pt)/6.);
}"&gt;&lt;/div&gt;

&lt;p&gt;Another confession: In truth, we haven't just been building a black and white image. We've been calculating a 2D distance estimator to the fractal. For any point in the plane, the value of our function is an approximation of the distance to the fractal. We can illustrate it by taking the modulo of the value:&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    pt = pt*.7;
    pt += vec2(.5,0.);
    pt = koch_curve(pt);
    return vec3(mod(d2hline(pt)/70.,1.));
}"&gt;&lt;/div&gt;

&lt;p&gt;Final confession: this distance estimator? It's not useful. At least, not in 2D. But it's &lt;em&gt;exactly&lt;/em&gt; what we need to draw pictures of three-dimensional KIFS fractals. &lt;a href="http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html"&gt;Raymarching&lt;/a&gt; is a rendering tool that can render pretty much any surface if you have an estimate of the distance to the surface from any point in space. &lt;/p&gt;
&lt;p&gt;All we need to adjust is adding some folds that live inside the &lt;span class="math"&gt;\(yz\)&lt;/span&gt; plane, rather than keeping in the &lt;span class="math"&gt;\(xy\)&lt;/span&gt; plane. Taking that distance estimate and plugging it into a raymarcher, we get similar 3D fractals! Try adjusting the fold angles to get a sense of the sorts of shapes this is capable of. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate override="DE" data="vec3 tri_fold(vec3 pt) {
    pt.xy = fold(pt.xy,PI/3.-cos(u_time)/10.);
    pt.xy = fold(pt.xy,-PI/3.);
    pt.yz = fold(pt.yz,-PI/6.+sin(u_time)/2.);
    pt.yz = fold(pt.yz,PI/6.);
    return pt;
}
vec3 tri_curve(vec3 pt) {
    for(int i=0;i&lt;7;i++){
        pt*=2.;
        pt.x-=2.6;
        pt=tri_fold(pt);
    }
    return pt;
}
float DE(vec3 p){
    p *= .75;
    p.x+=1.5;
    p=tri_curve(p);
    return (length( p*.004 ) - .01);
}
vec3 color(vec2 pt) {
    return simple_raymarch(pt);
}"&gt;&lt;/div&gt;

&lt;p&gt;You can play with the full source to this fractal &lt;a href="http://roy.red/editor/#/shaders/kifs.frag"&gt;here&lt;/a&gt;. This is a very simple and unoptimized renderer, and I'm not adept enough at writing raymarchers to tune it perfectly. More sophisticated and well-tuned renderers can draw much prettier pictures! &lt;/p&gt;
&lt;p&gt;For more information you should check out my main source for this post, Mikael Hvidtfeldt Christensen's &lt;a href="http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/"&gt;series on distance estimated 3D fractals&lt;/a&gt;, which covers KIFS and more. His program Fragmentarium comes with a number of KIFS fractals built in, and produces some very pretty results. &lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="glsl"></category></entry><entry><title>Building Escher's Square Limit in Pixels</title><link href="http://roy.red/building-eschers-square-limit-.html" rel="alternate"></link><published>2016-12-31T19:16:05-08:00</published><updated>2016-12-31T19:16:05-08:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-12-31:building-eschers-square-limit-.html</id><summary type="html">&lt;p&gt;&lt;a href = "https://www.wikiart.org/en/m-c-escher/square-limit?utm_source=returned&amp;utm_medium=referral&amp;utm_campaign=referral"&gt;&lt;img style="float: right;" width="300" src="http://roy.red/images/square-limit.jpg"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I've been fascinated by M.C. Escher's "Square Limit" print for a while. In the hopes of understanding it better I decided to try to generate my own square limit images. Drawing a Square Limit was done as early as 1981, more recently in &lt;a href="https://shashi.github.io/ijulia-notebooks/funcgeo/"&gt;Julia&lt;/a&gt;, using a functional approach. I didn't find these methods satisfying, partly because they relied on directly drawing each motif iteratively, even if they are using the symmetries of the piece. &lt;/p&gt;
&lt;p&gt;I built a way to render square limits with a GLSL fragment shader and in this post I'm going to walk through most of it and explain how it works. For a shader primer, check out the &lt;a href="http://thebookofshaders.com/"&gt;Book of Shaders&lt;/a&gt;. The important thing to know is that to write a fragment shader, you build a function that takes a location (in our case, of a pixel) and returns a color. All the code here is "live", though changes you make in each box will not cascade down to the subsequent ones- it's not a proper live coding environment. A full version of the code is linked at the end.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/bird-shape-2.png"/&gt;&lt;/p&gt;
&lt;p&gt;To start, we're going to to the fiddly bit, drawing the motif itself. I'm going to use a simplified motif of a bird borrowed from &lt;a href="http://www.tess-elation.co.uk/self-similar-tessellations"&gt;David Bailey&lt;/a&gt;. Looking at the simplified motif, it's more clear what symmetries exist. I've circled the four regions of the border that are related by by scaling, flipping, and rotation. The most flexible way to draw the motif is to exploit these symmetries. &lt;/p&gt;
&lt;p&gt;If you look closely at the original print, you'll notice that while it looks like one motif scaled and rotated many times, there are actually regular distortions in the shapes of the fish. For instance, where three fish come together, the fins are adjusted so they have threefold rotational symmetry, rather than coming together in a T shape. My square limit doesn't accurately capture these, but then neither do any of the other computer-generated square limits that I've seen. The way mine is drawn, it would not be too hard to manually adjust the motifs in these places but I'm going to leave it for the future.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;First, we draw one of the marked regions. It may not be immediately obvious why this draws a bump. It's just $y = -|x+.5|+.5 $ rewritten as an &lt;a href="https://www.desmos.com/calculator/t8yifdzokv"&gt;implicit formula&lt;/a&gt; so we can assign each pixel a value directly. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="float bird_shape(vec2 z){
    return 10.*(z.y+min(0.,abs(z.x+.5)-.5)+2.);
}
vec3 color(vec2 z) {
    return vec3(bird_shape(z*2.));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;Next we need to rotate and scale this shape three more times to form the bird shape. The shapes are composed together using &lt;code&gt;min&lt;/code&gt;, which may seem strange at first glance. The edge of our shape is defined by &lt;span class="math"&gt;\(f(z) = 0\)&lt;/span&gt;. If &lt;span class="math"&gt;\(h = min(f,g)\)&lt;/span&gt;, then &lt;span class="math"&gt;\(h(z) \leq 0\)&lt;/span&gt; when either &lt;span class="math"&gt;\(f(z)\)&lt;/span&gt; or &lt;span class="math"&gt;\(g(z)\)&lt;/span&gt; is. And on the other hand, &lt;span class="math"&gt;\(h(z) &amp;gt; 0\)&lt;/span&gt; if and only if &lt;span class="math"&gt;\(f(z) \gt 0\)&lt;/span&gt; and &lt;span class="math"&gt;\(g(z) \gt 0\)&lt;/span&gt;. So the shape we see after composing them with &lt;code&gt;min&lt;/code&gt; is the intersection- a logical AND- of the two original shapes. We're carving the plane into two regions, one inside the bird and one outside.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="float bird(vec2 z){
    float color = bird_shape(z)*smoothstep(-0.001,0.001,-z.x);
    // rot 180
    color -= bird_shape(z*mat2(-1,0,0,-1)+vec2(0,-4))*smoothstep(0.,0.001,z.x);
    z *= mat2(1.,1.,-1.,1.);// rot 45, scale
    z.y += 4.;
    z = vec2(z.x,-z.y);
    color = min(color,bird_shape(z*.5));
    z *= mat2(0.,1.,-1.,0.);
    z += 4.;
    color = min(color,-bird_shape(-z*.5));
    return smoothstep(-0.001,.001,color);;
}
vec3 color(vec2 z) {
    return vec3(bird(z*2.-vec2(0,1)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Now we can build the three-bird square that is the heart of the image. This needs to be drawn various times with various different colors, so this function takes parameters to adjust which colors are drawn. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="const vec3 light = vec3(0.995,0.964,0.573);
const vec3 mid = vec3(0.995,0.663,0.261);
const vec3 dark = vec3(0.995,0.390,0.314);
vec3 colors(int n,bool cycleDir){
    n = n &gt; 2? n-3: n; // modulo (int x) doesn't exist, so
    if (!cycleDir) n = 2 - n;
    return n == 2? mid: n == 1? dark: light;
}
vec3 three_birds(vec2 z, int t,bool s){
    vec3 color;
    z = z.yx;
    color = bird(z)*colors(t,s);
    color = mix(color,colors(1+t,s),bird(z*mat2(0,-1,1,0)));
    z = (z+vec2(-2.,-2.))*mat2(-.5,.5,.5,.5);
    color = mix(color,colors(2+t,s),bird(z));
    return color;
}
vec3 color(vec2 z) {
    return vec3(three_birds(z*3.,1,true));
}"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/simple-square-limit.png"/&gt;&lt;/p&gt;
&lt;p&gt;Now, we're going to switch gears. We don't want to draw every single bird by hand, so we're going to zoom out to look at the whole design. In a &lt;a href="/infinite-regression-.html#"&gt;previous post&lt;/a&gt;, I found a transformation that will "shatter" a square tile into an infinite regression inside a large square; see the last example in that post to understand how it works better. You can also play with the transformation in the &lt;a href="https://www.desmos.com/calculator/rju8punri0"&gt;Desmos online graphing calculator&lt;/a&gt;.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://roy.red/images/colored-square-limit.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/colored-square-limit.jpg"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rather than draw the same tile at each scale, to draw a proper square limit, some of the constituent tiles are going to necessarily be different from each other. At the center, for example, four motifs come together; along the diagonals, four motifs come together as well, though the coloring is different.&lt;/p&gt;
&lt;p&gt;To orient ourselves, we're just going to start with the scaling-transform and mask off each of the regions. We calculate the scaling factor twice, once in the &lt;span class="math"&gt;\(x\)&lt;/span&gt; and once in the &lt;span class="math"&gt;\(y\)&lt;/span&gt; direction. The magenta squares lie where the scaling factors in both directions are equal. The square in the middle has a scaling factor of two, so we will color that red with a special case. The green and yellow regions are distinguisable by which of &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(y\)&lt;/span&gt; are greater.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec2 scale_f(vec2 x){
    return exp2(-floor(log2(x)));
}
vec3 color(vec2 z) {
    z = (z+1.)*.75; 
    vec2 scale = scale_f(.75-abs(z-.75));
    if (scale.x == scale.y) {
        if (scale.x == 2.) // Center square
            return vec3(1,0,0);
        return vec3(1,0,1); // 'Corner' squares
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return vec3(0,1,0);
    } else { //scale.x &gt; scale.y
        // Left and right
        return vec3(1,1,0); 
    }
}"&gt;&lt;/div&gt;

&lt;p&gt;Here's the center tile. The corners of the "diamond" will get cropped down into a square flush around the central four birds. Four birds around the edge appear to be superfluous, but with a different motif they won't be, so it's much easier just to leave them in.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 center_tile(vec2 z){
    vec3 color = vec3(0);
    z = z.yx;
    z = z*4.-2.;
    z *= mat2(.5,.5,-.5,.5);

    for (int n=0;n&lt;=1;n++){
        // modulo(int) doesn't seem to exist, two loops
        // seems to be the cleanest way to do this.
        for (int m=0;m&lt;=1;m++){
            color += three_birds(z*2.+2.,m+1,m==1);
            z *= mat2(0,1,-1,0);
        }
    }
    return color;
}
vec3 color(vec2 z) {
    return vec3(center_tile(z+.5));
}"&gt;&lt;/div&gt;

&lt;p&gt;Next, the corner tiles. They're pretty fiddly, because they have two color schemes. I'm not sure there's any way to talk through the code that will make it more clear, so I'm going to show it as-is. It stamps two three-bird squares, and four individual birds to make up the other half.  &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 corner_tile(vec2 z,bool type){
    z = z.yx;
    z = z*4.-2.;
    int t = int(type);
    vec3 color = vec3(0);
    z *= mat2(.5,.5,-.5,.5);
    if ( t == 1 )
        z *= mat2(0,1,-1,0);

    color += three_birds(z*2.+2.,1+t,0+t ==1);
    z *= mat2(0,1,-1,0);
    color += three_birds(z*2.+2.,2-t,1-t ==1);
    z *= mat2(0,1,-1,0) * mat2(1,1,-1,1);
    color = mix(color,colors(0,true),bird(z));
    z *= mat2(0,-1,1,0);
    color = mix(color,colors(2-t,true),bird(z));
    z *= mat2(0,-1,1,0);
    color = mix(color,colors(1+t,true),
                bird(z+vec2(0.,-4.)));
    z *= mat2(0,-1,1,0);
    color = mix(color,colors(2,false),
                bird(z+vec2(0.,-4.)));
    return vec3(color);
}

vec3 color(vec2 z) {
    return vec3(corner_tile(z+.5,true));
}"&gt;&lt;/div&gt;

&lt;p&gt;Now the corner tiles can slot into our big square. Notice that the corner tiles on the bottom half need to be rotated 180 degrees around, compared to the top half. The entire print actually has 180 degree symmetry, so we can exploit this to create a copy of the entire top half on the bottom by modifying the coordinate system &lt;em&gt;before&lt;/em&gt; we draw anything.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate
 data="vec3 color(vec2 z) {
    // 180 degree rotational symmetry:
    if (z.y &lt; 0.) z=-z; 
    // The lower half is a 180-degree rotated copy
    z = (z+1.)*.75; 
    vec2 a_z = .75-abs(z-.75);
    vec2 scale = scale_f(a_z);
    if (scale.x == scale.y) {
        if (scale.x == 2.)// Center square
              return center_tile(z*2.-1.);
        else // 'Corner' squares
            return corner_tile(mod(z*scale,1.),z.x&gt;1.); 
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return vec3(0,1,0);
    } else { //scale.x &gt; scale.y
        // Left and right
        return vec3(1,1,0); 
    }
}"&gt;&lt;/div&gt;

&lt;p&gt;On the sides, instead of using a square tile, we use a rectangular one consisting of two three-bird tiles. As usual, we fill in the immediate neighbors around the edge. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 side_tiles(vec2 z,int colStart,bool cycleDir){
    z = -z*4. + vec2(6,2);
    vec3 col = three_birds(z,colStart,cycleDir);
    vec3 tile2 = three_birds(z*mat2(0,1,-1,0)+vec2(0,4)
,1+colStart,cycleDir);
    col = max(vec3(0.),col - tile2)+tile2;

    // fill in around the edge
    // Left and right
    col = mix(col, colors(2+colStart,cycleDir),
                   bird(z*mat2(0,-1,-1,0)-vec2(0,4)));
    col = mix(col, colors(  colStart,cycleDir),
                   bird(z*mat2(0,1,1,0)-vec2(0,8)));

    // Big top bird
    col = mix(col,colors(1+colStart,cycleDir),
                  bird((z-2.)*mat2(-.5,0,0,.5)+vec2(0.,-2.)));
    // Small bottom birds.
    z.x = mod(z.x-2.,4.)+2.;
    col = mix(col,colors(colStart,cycleDir),
                  bird((z-2.)*mat2(1,1,-1,1)+vec2(2.,6.)));
    col = mix(col,colors(2+colStart,cycleDir),
                  bird((z+vec2(-2,2))*mat2(1,-1,1,1)-2.));
    return col;
}

vec3 color(vec2 z) {
    return vec3(side_tiles(z*2.+1.,1,true));
}"&gt;&lt;/div&gt;

&lt;p&gt;Now we can drop the side tiles into our big square, and out pops the square limit!&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 z) {
    if (z.y &lt; 0.) z=-z; 
    z = (z+1.)*.75; 
    vec2 a_z = .75-abs(z-.75);
    vec2 scale = scale_f(a_z);
    if (scale.x == scale.y) {
        if (scale.x == 2.)// Center square
              return center_tile(z*2.-1.);
        else // 'Corner' squares
            return corner_tile(mod(z*scale,1.),z.x&gt;1.); 
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return side_tiles(mod(z*scale.y,2.),0,false);
    } else { //scale.x &gt; scale.y
        // Left and right
        // Rotate around so the right-hand side is correct:
        if (z.x &gt; 1.) z = -z;
        z = vec2(z.y,-z.x); // 90 degree rotation
        return side_tiles(mod(z*scale.x,2.),1,true);
    }
    return vec3(0);
}"&gt;&lt;/div&gt;

&lt;p&gt;Feel free to play with the complete source code &lt;a href="http://roy.red/editor/#/shaders/square limit-5.frag"&gt;in the editor&lt;/a&gt;. One thing to try changing is the motif- there are probably some more interesting ones! &lt;/p&gt;
&lt;div class="codeAndCanvas" literate  override="bird_shape" pre="vec3 sq_limit(vec2 z){
    if (z.y &lt; 0.) z=-z; z = (z+1.)*.75; 
    vec2 a_z = .75-abs(z-.75), scale = scale_f(a_z);
    if (scale.x == scale.y) {
        if (scale.x == 2.) return center_tile(z*2.-1.);
        else return corner_tile(mod(z*scale,1.),z.x&gt;1.); 
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return side_tiles(mod(z*scale.y,2.),0,false);
    } else { //scale.x &gt; scale.y
        if (z.x &gt; 1.) z = -z;
        z = vec2(z.y,-z.x); // 90 degree rotation
        return side_tiles(mod(z*scale.x,2.),1,true);
    }
}" data="float bird_shape(vec2 z){
    return 10.*(z.y+sin(u_time*3.)*min(0.,abs(z.x+.5)-.5)+2.);
}
vec3 color(vec2 z) {
    return sq_limit(z);
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;And a bonus: this method can easily be adjusted slightly to produce an analog of another Escher print, "Smaller and Smaller". Check out the source code in the editor &lt;a href="http://roy.red/editor/#/shaders/smaller-and-smaller-4.frag"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img style="" width="70%" src="http://roy.red/images/smaller.gif"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Infinite Regression: Many Pictures From One Function</title><link href="http://roy.red/infinite-regression-.html" rel="alternate"></link><published>2016-07-20T20:15:16-07:00</published><updated>2016-07-20T20:15:16-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-07-20:infinite-regression-.html</id><summary type="html">&lt;p&gt;&lt;a href="http://roy.red/images/regular-division-of-the-plane-vi.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/regular-division-of-the-plane-vi.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was interested in trying to imitate Escher's image, "Regular Division of the Plane IV", which depicts an infinite regression of tiles towards the edge. In doing so, I realized I'd re-written a function I'd seen elsewhere- in &lt;a href="http://www.gamedev.net/topic/590070-glsl-droste"&gt;generating Droste images&lt;/a&gt;- but hadn't looked at closely to understand what it could be used for. It's actually quite powerful and can be used to explore several of Escher's prints! So in this post I am going to play with this function and show how you can manipulate it to generate interesting scaling tilings, as well as a square Droste image (&lt;a href="/droste-.html"&gt;see previous&lt;/a&gt;). As usual there's an (over?)abundance of live code you can fiddle with. The code is GLSL. If GLSL is new to you, take a peek at the &lt;a href="https://thebookofshaders.com/"&gt;Book of Shaders&lt;/a&gt;; the editor will look familiar because I've borrowed it. &lt;/p&gt;
&lt;p&gt;The equation is extremely simple:&lt;/p&gt;
&lt;div class="math"&gt;$$f(x) = 2^{\lfloor \log_2{x}\rfloor}$$&lt;/div&gt;
&lt;p&gt;It turns out it has the exact property we need to draw this sort of image. It's plotted below; &lt;a href="https://www.desmos.com/calculator/4umgsbyrnk"&gt;see also in Desmos&lt;/a&gt;. It builds a staircase that grows a lot like &lt;span class="math"&gt;\(y = x\)&lt;/span&gt;, except that it has discrete jumps at every integer power of two. It also preserves some of the &lt;em&gt;dilational symmetry&lt;/em&gt; of &lt;span class="math"&gt;\(y=x\)&lt;/span&gt;: you can scale the whole thing by a power of two and you get the same plot. Ignoring the coloring, an extension of Escher's print across the whole half-plane would have the same exact symmetry.&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="float plot(vec2 st, float y){
  return  smoothstep( y-0.02, y, st.y) - 
          smoothstep( y, y+0.02, st.y);
}
float function(float x){
    return exp2(floor(log2(x)));
}
vec3 color(vec2 z) {
    z = (z+1.)*vec2(2.,1.02);
    return vec3(.9-plot(z,function(z.x)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Between &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; and &lt;span class="math"&gt;\(1.0\)&lt;/span&gt;, &lt;span class="math"&gt;\(f(x) = 0.5\)&lt;/span&gt;, and so forth, for adjacent powers of two:&lt;/p&gt;
&lt;div class="math"&gt;$$f(x) = 2^{n} \{ 2^n \leq x &amp;lt; 2^{n+1}\}$$&lt;/div&gt;
&lt;p&gt;This is exactly what we need. If you go back and look at the Escher print, there's a series of rows of tiles; each row is exactly half as tall as the one above, and the tiles within it are half as big. &lt;/p&gt;
&lt;p&gt;To start with, we need lots of copies of our image. Here a circle radius &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; is used to tile the plane.&lt;/p&gt;
&lt;div  style='clear:right' class="codeAndCanvas" data="float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    z += 1.;
    // fract == modulo 1.0
    return vec3(circle(fract(z)));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;We then use &lt;span class="math"&gt;\(f(z.x)\)&lt;/span&gt; as a scaling factor, and out pops the Escher-type tiling that I was interested in at the beginning! Notice how in this picture, each "column" of circles lines up with a "step" of the plot of &lt;span class="math"&gt;\(f\)&lt;/span&gt; above.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float f(float x){
    return exp2(floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    z += 1.;
    float scale = f(z.x);
    z /= scale;
    return vec3(circle(fract(z)));
}"&gt;&lt;/div&gt;

&lt;p&gt;But once we've got this function, we can use it to draw more things! For instance, something reminiscent of Escher's &lt;a href="http://www.wikiart.org/en/m-c-escher/smaller-smaller"&gt;Smaller and Smaller&lt;/a&gt;. Instead of dividing by &lt;code&gt;scale&lt;/code&gt;, we multiply by the reciprocal (multiplication is faster). The input to &lt;span class="math"&gt;\(f\)&lt;/span&gt; is calculated as the larger of &lt;span class="math"&gt;\(\left|x\right|\)&lt;/span&gt; and &lt;span class="math"&gt;\(\left|y\right|\)&lt;/span&gt; which produces a characteristic square pattern. The mathematics of &lt;em&gt;that&lt;/em&gt; is either fiddly or obvious, depending on whether you've seen it before, so I'm going to skip over the derivation. &lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="//'Smaller and Smaller'
float f(float x){
    return exp2(-floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    vec2 a_z = abs(z);
    float scale = f(max(a_z.x,a_z.y));
    return vec3(circle(fract(z*scale)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Looking at this, I saw the obvious similarity to Droste images; it is a Droste image, except that we've got extra copies of the original. "Extra copies" is a good problem to have, because we're just a constant or two away from a classic square Droste picture. &lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x){
    return exp2(-floor(log2(x))-2.); // here's the change
}

vec3 color(vec2 z) { 
    vec2 a_z = abs(z);
    float scale = f(max(a_z.x,a_z.y));
    return texture2D(u_tex0,z*scale+0.5).xyz;
}"&gt;&lt;/div&gt;

&lt;p&gt;And now we can apply Escher's twist that &lt;a href="/droste-.html"&gt;I implemented previously&lt;/a&gt;. This time though, we don't need to use any modulo function, since we already have our infinitely nesting copies. This makes the transformation nearly a one-liner.&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x){
    return exp2(-floor(log2(x)));
}
vec3 color(vec2 z) { 
    float angle = atan(log(2.)/(2.0*PI));
    z = cExp(cDiv(cLog(z), cExp(vec2(0,angle))*cos(angle))); 
    vec2 a_z = abs(z);
    z *= f(max(a_z.x,a_z.y)*2.);
    return texture2D(u_tex0,z*.5+0.5).xyz;
}"&gt;&lt;/div&gt;

&lt;p&gt;The obvious generalization to &lt;span class="math"&gt;\(f\)&lt;/span&gt; is to allow an arbitrary exponent, and it turns out it also generalizes our Droste too, adjusting how deep each copy is created. &lt;/p&gt;
&lt;div class="math"&gt;$$f(x,n) = n^{\lfloor \log_n{x}\rfloor}$$&lt;/div&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x,float n){
    return pow(n,-floor(log(x)/log(n)));
}
vec3 color(vec2 z) {
    float ratio = 5.264;
    float angle = atan(log(ratio)/(2.0*PI));
    z = cExp(cDiv(cLog(z), cExp(vec2(0,angle))*cos(angle)));
    vec2 a_z = abs(z);
    z *= f(max(a_z.x,a_z.y)*2.,ratio);
    return texture2D(u_tex0,z/ratio+.5).xyz;
}"&gt;&lt;/div&gt;

&lt;p&gt;And with some more constants and an adjustment, there's a simple version of Escher's &lt;a href="http://www.wikiart.org/en/m-c-escher/square-limit?utm_source=returned"&gt;Square Limit&lt;/a&gt; hidden inside here as well!&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="float f(float x){
    return exp2(-floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    // Arrived at by motivated guesswork
    z = (z+1.)*.75;
    vec2 a_z = .75-abs(z-.75);
    return vec3(circle(fract(z*f(min(a_z.x,a_z.y)))));
}"&gt;&lt;/div&gt;

&lt;p&gt;That's all for now! If you want to have some more fun with Droste images, check out my previous post on &lt;a href="/fractal-droste-images-.html"&gt;fractally-distorted drostes&lt;/a&gt;. Or perhaps take a leap into the &lt;a href="/slitscan-.html"&gt;Time Tunnel&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;See also:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Bailey's &lt;a href="http://www.tess-elation.co.uk/self-similar-tessellations"&gt;World of Tessellations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shashi.github.io/ijulia-notebooks/funcgeo/"&gt;Functional Geometry in Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Drawing fractal Droste images</title><link href="http://roy.red/fractal-droste-images-.html" rel="alternate"></link><published>2016-05-17T21:31:41-07:00</published><updated>2016-05-17T21:31:41-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-05-17:fractal-droste-images-.html</id><summary type="html">&lt;p&gt;&lt;a href="https://www.flickr.com/photos/fpsurgeon/2680685329/in/pool-escherdroste"&gt;&lt;img style="float: right;" width="300" src="http://roy.red/images/2droste.jpg"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;When I was researching Droste images for a &lt;a href="/droste-.html"&gt;previous post&lt;/a&gt;, I occasionally came across strange versions which depicted multiple spirals, rather than the customary single spiral, like this one by David Pearson. This led me down a rabbit hole to understand what is actually going on in these images, and to see what I could make with the effect. &lt;/p&gt;
&lt;p&gt;This is going to be a longer post, so feel free to scroll to the end to see the final fractal results. Spoiler alert: Mandelbrots.&lt;/p&gt;
&lt;p&gt;As with my previous posts, the embedded examples are all live shader code, and will automatically update as you edit them. They might not work correctly on all computers; your browser must support WebGL without too many bugs.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;To begin with, I'm going to talk about complex functions. Complex functions take a complex number as input and return another. It's a bit tricky to visualize them, since between the two-dimensional range and two-dimensional domain, the result is four-dimensional. A common method for visualizing these functions is &lt;a href="https://en.wikipedia.org/wiki/Domain_coloring"&gt;domain coloring&lt;/a&gt;.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    return vec3(hsv2rgb(vec3(atan(z.y,z.x)/PI2,1.,1.)));
}
vec3 color(vec2 z) {
    return domain(z);
}"&gt;&lt;/div&gt;

&lt;p&gt;The idea behind domain coloring is that you draw a picture of a complex function &lt;span class="math"&gt;\(f: \mathbb{ C } \mapsto \mathbb{ C }\)&lt;/span&gt; by coloring the domain and pulling those colors back by &lt;span class="math"&gt;\(f\)&lt;/span&gt;. In other words you color &lt;span class="math"&gt;\(z\)&lt;/span&gt; the same as &lt;span class="math"&gt;\(f(z)\)&lt;/span&gt; is colored. The particular method I'm using is called a phase portrait, borrowed from Elias Wegert. It colors the domain by the phase, or the angle it makes with the positive real axis. For more information, &lt;a href="http://www.ams.org/notices/201106/rtx110600768p.pdf"&gt;his article on the subject&lt;/a&gt; is a must-read.&lt;/p&gt;
&lt;p&gt;In the example above, I'm just drawing the domain with no complex function at all (or, if you like, the identity &lt;span class="math"&gt;\(f: z \mapsto z\)&lt;/span&gt;). Notice that it's very obvious where &lt;span class="math"&gt;\(0\)&lt;/span&gt; is, because the colors all "bunch up" around it. We'll see a similar effect near the zeros of a more complicated function. Here is the phase portrait for &lt;span class="math"&gt;\(f: z \mapsto z / (z^2 + z + 1)\)&lt;/span&gt;. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    return vec3(hsv2rgb(vec3(atan(z.y,z.x)/PI2,1.,1.)));
}
vec3 color(vec2 z) {
    z = z * 2.;
    z = cDiv(z-vec2(1.,0), cMul(z,z)+z+vec2(1.,0));
    return domain(z);
}"&gt;&lt;/div&gt;

&lt;p&gt;Something funny's happening. There's three zero-like regions, but the two on the left are different- if you follow the hues around in a circle, they are cycling the "wrong way". They're not zeros at all, but poles: the center of these regions is where &lt;span class="math"&gt;\(f\)&lt;/span&gt; goes to infinity. You can't explain this easily without invoking the Riemann sphere, which is much less intimidating than it sounds. &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img width="60%" src="http://upload.wikimedia.org/wikipedia/commons/7/7c/Riemann_sphere1.jpg"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Imagine that the complex plane is actually sitting in 3D space. If you place a sphere at the origin, you can &lt;a href=""&gt;stereographically project&lt;/a&gt; points on the plane (complex numbers) to the sphere and back again, by casting a ray out from the top of the sphere. The lower hemisphere is identified with the unit disk, while the northern upper is identified with the entire rest of the plane. This is the Riemann sphere. An ant that lives on the complex plane that starts at the origin, can march outwards and the further it goes, the further its twin on the sphere approaches the north pole. If we map our domain coloring to the Riemann sphere, the colors get "gathered together" at the top of the sphere, which is why they gather together around infinities as well. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    return vec3(hsv2rgb(vec3(atan(z.y,z.x)/PI2,1.,1.)));
}
vec3 color(vec2 z) {
    float onSphere;
    // sphereViewer textures a sphere by stereographic projection
    z = sphereViewer(z,onSphere); 
    if (onSphere &gt; 0.)
        // Color this part of the sphere by its projection
        return domain(z)-circle(z,.5);
    return vec3(0);
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;On the sphere above, I've drawn a circle with radius &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; to help orient us; it gets projected to the lower hemisphere. Wave your mouse cursor over the sphere to tip it up and down. The sphere is &lt;a href="http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html"&gt;raymarched&lt;/a&gt; based on &lt;a href="http://glslsandbox.com/e#29798.0"&gt;this code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The next step is to note that a logarithmic spiral projected back onto the sphere is a &lt;a href="https://www.jasondavies.com/maps/loxodrome/"&gt;loxodrome&lt;/a&gt;, or rhumb line. This is caused by the logarithmic spiral being also "equiangular": at every point, if you draw a circle centered at the origin that goes through it, the tangent will always make the same angle with the circle. Under stereographic projection, that circle becomes a &lt;a href="https://en.wikipedia.org/wiki/Latitude"&gt;parallel&lt;/a&gt;. Luckily for us, it's easy to generate one: a circle transformed by the droste effect is a logarithmic spiral. Let's superimpose that on our domain coloring to see how it looks on the sphere. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    // r1=0.7, r2=1.4:
    z = droste_(z,0.7,1.4);
    return circle(z,1.)+vec3(hsv2rgb(vec3(atan(z.y,z.x)/PI2,1.,1.)));
}
vec3 color(vec2 z) {
    float onSphere;
    z = sphereViewer(z,onSphere); 
    return onSphere&gt;0.? domain(z): vec3(0);
}"&gt;&lt;/div&gt;

&lt;p&gt;The awesome thing here is that we have a smooth spiral that is (roughly speaking) symmetrical across the equator. If we leave this spiral in our domain coloring, we will get smooth spirals around the zeros and poles of the phase portrait. So far as I know, this is actually a new (or at least rarely used) way to visualize complex functions.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    z = droste_(z,0.7,1.4);
    return circle(z,1.)+phase_portrait(z);
}
vec2 f(vec2 z){
    z = z * 2.;
    return cDiv(z-vec2(1.,0), cMul(z,z)+z+vec2(1.,0));
}
vec3 color(vec2 z) {
    return domain(f(z));
}"&gt;&lt;/div&gt;

&lt;p&gt;The big reveal here is, we're not just working with logarithmic spirals. We're working with the droste effect! So we can draw a complicated Droste image in the domain and it will behave in a similar way. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    z = droste_(z,0.5,1.0);
    return planetaryLinkage(z);
}
vec2 f(vec2 z){
    z = z * 2.;
    return cDiv(z-vec2(1.,0), cMul(z,z)+z+vec2(1.,0));
}
vec3 color(vec2 z) {
    //float onSphere;
    //z = sphereViewer(z,onSphere); 
    //if (onSphere &gt; 0.)
    return domain(f(z));
    //return vec3(0);
}"&gt;&lt;/div&gt;

&lt;p&gt;To draw the two-spiral effect that we saw in the original image, we transform the domain with a &lt;a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation"&gt;M√∂bius transformation&lt;/a&gt; &lt;span class="math"&gt;\(z \mapsto \frac{z-1}{z+1}\)&lt;/span&gt;. Notice that this function has one zero at &lt;span class="math"&gt;\(z=1\)&lt;/span&gt; (the numerator is &lt;span class="math"&gt;\(0\)&lt;/span&gt;) and a pole at &lt;span class="math"&gt;\(z=-1\)&lt;/span&gt; (the denominator is &lt;span class="math"&gt;\(0\)&lt;/span&gt;). This is equivalent, as you can see, to &lt;a href="https://www.youtube.com/watch?v=JX3VmDgiFnY"&gt;tipping&lt;/a&gt; the Riemann sphere sideways by 90 degrees. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    z = droste_(z,0.7,1.4);// r1=0.7, r2=1.4:
    return circle(z,1.)+phase_portrait(z);
}
vec2 f(vec2 z){
    return cDiv(z+vec2(-1,0),z+vec2(1,0));
}
vec3 color(vec2 z) {
    float onSphere; z = sphereViewer(z,onSphere); 
    return onSphere&gt;0.? domain(f(z)): vec3(0);
}"&gt;&lt;/div&gt;

&lt;p&gt;The result applied to our droste domain is more or less similar to the two-spiraled effect that we wanted to emulate in the first place. &lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;div class="codeAndCanvas" data="vec3 domain(vec2 z){
    z = droste_(z,0.5,1.0);
    return planetaryLinkage(z);
}
vec2 f(vec2 z){
    return cDiv(z+vec2(-1,0),z+vec2(1,0));
}
vec3 color(vec2 z) {
    return domain(f(2.*z));
}"&gt;&lt;/div&gt;

&lt;p&gt;From here, there's any number of complex functions we could play with. Elias Wegert's &lt;a href="http://www.mathe.tu-freiberg.de/~wegert/PhasePlot/images.html"&gt;phase plot gallery&lt;/a&gt; gives a sense of the variety. I decided to draw a Mandelbrot / Julia set. &lt;/p&gt;
&lt;p&gt;The simplest method to draw a Mandelbrot image is to iterate each point &lt;span class="math"&gt;\(z_0\)&lt;/span&gt; through the Mandelbrot function &lt;span class="math"&gt;\(m(z) = z^2 + z_0\)&lt;/span&gt; until it escapes (or doesn't) and then coloring the pixel accordingly, giving up at some large number of iterations. Instead, we're just going to apply the function &lt;span class="math"&gt;\(n\)&lt;/span&gt; times and ignore whether it's escaping or not, to produce a function &lt;span class="math"&gt;\(M_n\)&lt;/span&gt;. Here I draw &lt;span class="math"&gt;\(M_3\)&lt;/span&gt;:&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec2 M(vec2 z,vec2 c){    
    // Iterate m(z) 3 times
    for (int i=0; i&lt;3;i++){
        z = cPower(z,2.) + c;
    } return z;
}
vec3 domain(vec2 z){
    //return phase_portrait(z);
    z = droste_(z,0.5,1.0);
    return planetaryLinkage(z);
}
vec3 color(vec2 z) {
    vec2 z0 = (z = z*2.-vec2(0.5,0.));
    z = M(z,z0);
    return domain(z);
}"&gt;&lt;/div&gt;

&lt;p&gt;This produces an interesting result, but I found that applying the Mobius transformation I used before produces a more satisfying picture. This is because the &lt;span class="math"&gt;\(M_n\)&lt;/span&gt; function (in the limit) maps the interior of the Mandelbrot set onto the unit disk. Placing the top and bottom of the loxodrome on the unit circle means that the "interesting" parts of the domain get mapped to somewhere near the boundary. &lt;/p&gt;
&lt;p&gt;Instead of tipping the whole domain, you can just shift the top pole to the unit circle and leave the zero alone with &lt;span class="math"&gt;\(z \mapsto \frac{z}{z+1}\)&lt;/span&gt;. It produces better results for slightly higher values of &lt;span class="math"&gt;\(n\)&lt;/span&gt;, because it's drawing spirals between the boundary of the Mandelbrot and the zeros in the interior. Try experimenting with this here, and above to see what it does to the Riemann sphere.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec2 M(vec2 z,vec2 c){    
    for (int i=0; i&lt;5;i++){
        z = cPower(z,2.) + c;
    } return z;
}
vec3 domain(vec2 z){
    float shade = 0.5-1.*(dot(z,z)-.7);
    z = cDiv((z+vec2(-1,0.000)),(z+vec2(1.0,0.00)));
    //z = cDiv(z-cis(u_time),(z+cis(u_time))); //rotations
    //z = cDiv(z,(z+vec2(1.0,0.0))); //squash-tipping
    //return phase_portrait(z)*shade;
    z = droste_(z,0.5,1.0);
    return planetaryLinkage(z)*shade;
}
vec3 color(vec2 z) {
    z = z*1.2-vec2(0.5,0.);
    vec2 z0 = z;
    z = M(z,z0);
    return domain(z);
}"&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;And finally, here's an interactive animation of the Julia set; it alters the parameter &lt;span class="math"&gt;\(c\)&lt;/span&gt; based on mouse movement. This looks a bit like an orbit trap, but it's not: orbit traps take the point with the smallest magnitude, I'm just taking the final one. &lt;/p&gt;
&lt;p&gt;There is also &lt;a href="/julia-view.html"&gt;a version listing the full source code&lt;/a&gt; rather than the abbreviated code displayed so far. &lt;/p&gt;
&lt;div class="codeAndCanvas extrabig" data="vec2 M(vec2 z,vec2 c){    
    for (int i=0; i&lt;6;i++){
        z = cPower(z,2.) + c;
    } return z;
}
vec3 domain(vec2 z){
    float shade = 0.5-1.*(dot(z,z)-.7);
    //return phase_portrait(z)*shade;
    z = droste_(z,0.5,1.0);
    return planetaryLinkage(z)*shade;
}
vec3 color(vec2 z) {
    vec2 c = mouse_uv();
    //vec2 c = vec2(-0.580,0.460)+cis(u_time)/10.;
    z = M(z*1.5,c);
    return domain(z);
}"&gt;&lt;/div&gt;

&lt;h3&gt;Further reading&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://westy31.home.xs4all.nl/Geometry/Geometry.html#Fractal_tiling"&gt;Platonic tilings of Riemann surfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.malinc.se/m/"&gt;Malin Christerrson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.mathe.tu-freiberg.de/~wegert/visual/index.htm"&gt;Elias Wegert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.dhushara.com/DarkHeart/DarkHeart.htm"&gt;Exploding the Dark Heart of Chaos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://archive.bridgesmathart.org/2013/bridges2013-217.pdf"&gt;The Mercator Redemption&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="droste"></category></entry><entry><title>Fun with interference patterns</title><link href="http://roy.red/interference-.html" rel="alternate"></link><published>2016-05-04T21:04:56-07:00</published><updated>2016-05-04T21:04:56-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-05-04:interference-.html</id><summary type="html">&lt;p&gt;Ordinary trigonometric functions can produce really interesting, structured patterns if you use sufficiently large numbers. There's nothing fancy happening here, but at different scales and with different constants, the result can change quite drastically. Try zooming in (&lt;code&gt;z = z * 0.01&lt;/code&gt; for instance) and you'll see that it's just bands of white and black. It's only when you zoom out that creeping bands moving in crazy directions appear.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 z) {
    z = z * 1.;
    float r=length(z);
    return vec3(sin(cos(r)*r*(u_time+1000.)*10.0));
}"&gt;&lt;/div&gt;

&lt;p&gt;I'm fairly sure this is a straightforward consequence of interference. The square grid of pixels is sampling the underlying equation at regular intervals. The result is a kind of &lt;a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern"&gt;moir√© pattern&lt;/a&gt;. For photography and graphics applications aliasing is Bad News, but you can harness it to produce interesting patterns. &lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;Anyway, math aside, you can pretty much just start messing with constants and mushing trigonometric functions together here and see what happens. It inherits some of the rotational symmetry of the underlying pattern, so we end up with something that isn't completely mush. Plugging the time variable into a periodic function like &lt;code&gt;sin&lt;/code&gt; lets us quite easily find interesting loops, ripe for the giffing. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    pt = pt * 1.6;
    float r = length(pt);
    float stime = 4.*sin(u_time * 2. * PI)+100.;
    return vec3(r+cos(cos(r*r*100.)*stime));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;My current "fancy" way to gif something is to render it in &lt;a href="https://syntopia.github.io/Fragmentarium/index.html"&gt;Fragmentarium&lt;/a&gt; and take the resulting pngs and run them through &lt;a href="https://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt;'s &lt;code&gt;convert&lt;/code&gt; utility. This is a bit fiddly, so often I just use my favorite program: &lt;a href="http://blog.bahraniapps.com/gifcam/"&gt;GifCam&lt;/a&gt;! It's a tiny utility that records gifs directly off your screen. It certainly won't produce the best, smallest, lowest-artifact gif, but it's easy to use and the results aren't half bad!&lt;/p&gt;
&lt;p&gt;&lt;img width="250" src="/images/interference-1.gif"/&gt;
&lt;img width="250" src="/images/circles_m.gif"/&gt;
&lt;img width="250" src="/images/mandala2.gif"/&gt;&lt;/p&gt;</summary></entry><entry><title>Recreating the Doctor Who Time Tunnel in GLSL</title><link href="http://roy.red/slitscan-.html" rel="alternate"></link><published>2016-04-27T21:34:06-07:00</published><updated>2016-04-27T21:34:06-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-04-27:slitscan-.html</id><summary type="html">&lt;p&gt;&lt;img style="float: right;" width="300" src="http://roy.red/images/stargate.gif"/&gt;&lt;/p&gt;
&lt;p&gt;The slit-scan effect is a classic analog special effect. It was most famously used during the "Stargate" sequence in 2001: A Space Odyssey, and a title sequence in Doctor Who. It was done "in camera"- no CGI here at all. It's simple enough that it turns out this effect is absolutely begging to be implemented as a WebGL &lt;a href="http://patriciogonzalezvivo.com/2015/thebookofshaders/01/"&gt;fragment shader&lt;/a&gt;, and the transformation can be done in only a few lines of code! &lt;/p&gt;
&lt;p&gt;FilmmakerIQ produced a great explanation on how the method works practically. It's not required watching, but it explains it visually and shows how it was done.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;iframe src="https://player.vimeo.com/video/71702374" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;In case you prefer text: the idea is that you want an animation flying through an animated tunnel. You cut a slit in a card; behind that card is colored plastic brightly lit from behind. You open the camera's shutter and pull it back from the slit. From the point of view of the camera, the slit shrinks and approaches the vanishing point at the center of the frame. Since you did a long exposure, the entire trail of the slit is exposed: it looks like a foreshortened rectangle.&lt;/p&gt;
&lt;p&gt;The real trick is that you move the transparency horizontally (behind the slit) as the camera is moved backward. Successive slices of the texture on the transparency will get exposed to successively "further away" slices on the foreshortened rectangle on film. After you expose one frame, you reset the setup except you advance the start position of the transparency slightly. Rinse repeat and suddenly you have an animated tunnel. &lt;/p&gt;
&lt;p&gt;It turns out you can perform the same tric with an arbitrarily-shaped "slit." Instead of a line, your slit can be a square, a circle, or probably anything. The second-most famous use of the slit-scan showed multiple shapes off: for the Doctor Who time-tunnel, there's even a TARDIS-shaped effect!&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;iframe width="640" height="360" src="https://www.youtube.com/embed/1fnzcAFy8d8" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;That's enough intro. Let's start implementing the sequence I found most intriguing: the circular tunnel from Doctor Who. Don't forget that the examples here are all live: you can tweak them and the visuals will update themselves thanks to code borrowed from the &lt;a href="http://patriciogonzalezvivo.com/2015/thebookofshaders/"&gt;Book of Shaders&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To start with, we need a texture. Different textures produce widely varying results, but here's one good one using iq's &lt;a href="https://www.shadertoy.com/view/Xd23Dh"&gt;voronoise&lt;/a&gt;. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    return vec3(iqnoise(5.*pt,1.,1.));
}"&gt;&lt;/div&gt;

&lt;p&gt;So. Let's think about the physical way the time-tunnel is created. A given frame can be thought of as composed of a large number of concentric rings, each one corresponding to an exposure of the circular slit imaged at different distances. If a strobe was flashed as the camera moved, there really would be a bunch of visible rings. &lt;/p&gt;
&lt;p&gt;If the transparency never moves, the rings in the final image will all correspond to the &lt;em&gt;same&lt;/em&gt; ring in the original. Let's decide that it's the &lt;a href="https://en.wikipedia.org/wiki/Unit_circle"&gt;unit circle&lt;/a&gt; (centered at the origin with radius 1). To find how to color a particular pixel, we are going to divide it by its distance to the origin. This will scale it up or down to lie on the unit circle.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    pt = pt / length(pt);
    return vec3(iqnoise(5.*pt,1.,1.));
}"&gt;&lt;/div&gt;

&lt;p&gt;Well! That looks about right. It's got the feel of a Star Wars hyperspace jump. The problem is, we're mapping everything to the same slit without moving the pattern, so to speak. &lt;/p&gt;
&lt;p&gt;We need to displace the pattern horizontally, but how much? It turns out the right answer is exactly &lt;code&gt;1 / length(pt)&lt;/code&gt;. This was arrived at by motivated guessing, but the explanation is fairly straightforward. In general, the apparent size of an object is proportional to the reciprocal of its depth in the scene. The inverse of the distance to the origin is exactly how far along each ring is in the tunnel, and we want to paint the texture along the inside of the tunnel. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    float rInv = 1./length(pt);
    pt = pt * rInv - vec2(rInv,0.0);
    return vec3(iqnoise(5.*pt,1.,1.));
}"&gt;&lt;/div&gt;

&lt;p&gt;And suddenly (shockingly) we've found ourselves in a time tunnel.&lt;/p&gt;
&lt;p&gt;With a few tweaks, you can animate the tunnel and begin to approach the original effect.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    pt = 1.2*pt;
    float rInv = 1./length(pt);
    pt = pt * rInv - vec2(rInv+2.*mod(u_time,6000.),0.0);
    vec3 color = vec3(0.659,0.772,1.000);
    return color*vec3(iqnoise(5.*pt,1.,1.)+0.240*rInv);
}"&gt;&lt;/div&gt;

&lt;p&gt;What's really fun is that we really are mimicking the original analog transformation, all without drawing a single polygon. I misspent a few hours hand-painting a texture, and managed to render a tunnel whose outlines match the original more or less exactly, so I am confident that this transformation (ignoring constants) really is equivalent to a slit-scan.&lt;/p&gt;
&lt;div style='position:relative;padding-bottom:calc(50% / 2.00);clear:right;'&gt;&lt;iframe src='https://gfycat.com/ifr/IdealFamiliarCusimanse' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;Perhaps you want a different shaped tunnel. It's quite easy to induce different shapes simply by altering the distance function. Instead of taking &lt;code&gt;length(pt)&lt;/code&gt;, we will use our own function. By and large, a graph of the &lt;a href="https://en.wikipedia.org/wiki/Contour_line"&gt;contour lines&lt;/a&gt; of this function will reflect the apparent shape of the tunnel. Comment out the marked lines here to experiment with different distance functions. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="float dist(vec2 pt) {
    //return min(abs(pt.x+pt.y),abs(pt.x-pt.y))+0.001;
    //return abs(pt.x+pt.y);
    //return abs(pt.x)+abs(pt.y);
    //return max(abs(pt.x),abs(pt.y));
    return abs(pt.x);
}
vec3 color(vec2 pt) {
    float rInv = 1./dist(pt);
    // Uncomment below to show contours
    // return vec3(fract(rInv));
    pt = pt * rInv - vec2(rInv+mod(u_time,6000.),0.0);
    return vec3(iqnoise(5.*pt,1.,1.)+0.09*rInv);
}"&gt;&lt;/div&gt;

&lt;p&gt;I also have a version of this &lt;a href="https://www.shadertoy.com/view/4dtSWS"&gt;published on Shadertoy&lt;/a&gt; (warning: autoplay sound). That's all for now! There is surely more to explore here- for instance, I haven't found any obvious distance functions that approximate a TARDIS outline, or Tom Baker's head...&lt;/p&gt;</summary><category term="drwho"></category><category term="glsl"></category></entry><entry><title>Implementing the Droste effect in WebGL</title><link href="http://roy.red/droste-.html" rel="alternate"></link><published>2016-04-25T22:33:23-07:00</published><updated>2016-04-25T22:33:23-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-04-25:droste-.html</id><summary type="html">&lt;noscript&gt;&lt;h3&gt;Hi! It looks like you've turned off Javascript. I'm sorry to say that WebGL and math rendering require Javascript, so this post will appear broken with Javascript turned off.&lt;/h2&gt;&lt;/noscript&gt;

&lt;p&gt;&lt;a href="http://roy.red/images/Droste.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/Droste.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this post, I'm going to explore how to implement the so-called "&lt;a href="https://en.wikipedia.org/wiki/Droste_effect"&gt;Droste effect&lt;/a&gt;." The Droste effect is a name given to pictures that contain themselves, like an infinite series of nesting dolls. The conventional Droste effect is interesting, but it was taken to new heights by M.C. Escher's "Print Gallery." &lt;/p&gt;
&lt;p&gt;&lt;a href="http://escherdroste.math.leidenuniv.nl/images/scan450.jpg"&gt;&lt;img style="float: left; margin-right:1em; margin-bottom:0.5em" src="http://roy.red/images/print-gallery.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The Print Gallery has the peculiar quality that if you follow the gaze of the person in the lower right corner, into the picture he is looking at, and around the image clockwise you find that you have come back to where you started: looking at a figure, looking at a picture. In some sense, this is a "Droste" picture: the print gallery contains a picture of the city that the print gallery is located in, except "zooming in" is replaced by walking around the origin. &lt;/p&gt;
&lt;p&gt;&lt;a href="http://escherdroste.math.leidenuniv.nl/"&gt;Mathematicians and artists in the Netherlands&lt;/a&gt; managed to reverse-engineer the picture, and determined a transformation that can take an ordinary Droste image to a &lt;a href="https://www.flickr.com/search/?text=droste%20effect"&gt;twisted, Escher-like image&lt;/a&gt;. They published an &lt;a href="http://www.ams.org/notices/200304/fea-escher.pdf"&gt;article&lt;/a&gt; explaining how it works, but on first and second reading I will admit I could make neither head nor tails of it. If it makes more sense to you, the rest of this post is going to be mostly superfluous! If you want to play with an existing implementation, check out &lt;a href="http://www.photospiralysis.com/"&gt;Photospiralysis&lt;/a&gt;, which works in the browser.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://roy.red/images/droste-rect.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/droste-rect-thumb.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I wanted to understand how Escher's Print Gallery effect actually worked, and implement it myself. Luckily, the incomparable Jos Leys has written a pretty straightforward &lt;a href="http://www.josleys.com/article_show.php?id=82"&gt;explanation&lt;/a&gt;, with pictures &amp;amp; equations. Most of the following is going to be lifted directly from his article, except we're going to implement it as we read along. I recommend you read his article first, or at least give it a skim.&lt;/p&gt;
&lt;p&gt;The implementation will be as a GLSL fragment shader (aka pixel shader). These are fast, and if you stick to GLSL2.0, it will work happily in the browser and many other places. If you've never touched fragment shaders, it would help to at least glance over &lt;a href="http://patriciogonzalezvivo.com/2015/thebookofshaders/"&gt;The Book of Shaders&lt;/a&gt; first. I am borrowing the author's code framework for displaying live examples.&lt;/p&gt;
&lt;p&gt;Jos Leys explains how the transformation goes forward from a square picture to a Droste picture. To work as a fragment shader, we're going to &lt;strong&gt;invert the transformation&lt;/strong&gt;. For each point in the Droste picture, we work out which point on the original picture maps to it, and color our pixel accordingly. Working in this mode gives a feel of "warping space" rather than warping the image directly. &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;We'll begin the same: with an annulus, the area between two circles. I am eliding how the annulus is actually drawn, mostly because I'm not an expert shader writer and my code isn't great. Read The Book of Shaders linked above if you want to learn more about drawing shapes in GLSL.&lt;/p&gt;
&lt;p&gt;Don't forget that these examples are editable: adjust parameters and comment code out to see how it changes the result.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.3;
float r2 = 0.7;
vec3 color(vec2 z) {
    return circles(z,r1,r2);
}"&gt;&lt;noscript&gt;&lt;pre&gt;float r1 = 0.3;
float r2 = 0.7;
vec3 color(vec2 z) {
    return circles(z,r1,r2);
}&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;

&lt;p&gt;We are going to think of the annulus as actually sitting in the &lt;a href="https://en.wikipedia.org/wiki/Complex_plane"&gt;complex plane&lt;/a&gt;. We can perform complex arithmetic on our pixels! If you're unfamiliar with complex numbers, it suffices for our purposes to know that complex numbers have two "coordinates" (real and imaginary) and points in the complex plane can be represented as a single number: &lt;span class="math"&gt;\((x,y)\)&lt;/span&gt; in the ordinary plane can be thought of as &lt;span class="math"&gt;\(x+yi\)&lt;/span&gt;, a complex number. In GLSL, complex numbers are stored identically to a point in the plane: a &lt;code&gt;vec2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can perform arithmetic on complex numbers in similar ways to ordinary numbers. Addition, multiplication, and exponentiation all have equivalents in the complex plane. Most important for us is the &lt;a href="https://en.wikipedia.org/wiki/Exponentiation#Imaginary_exponents_with_base_e"&gt;complex exponent&lt;/a&gt; and its inverse, the complex logarithm.&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(z \rightarrow \log(z)\)&lt;/span&gt; has the property that it transforms complex numbers within &lt;span class="math"&gt;\(r\)&lt;/span&gt; units of the origin into a strip &lt;span class="math"&gt;\(2 \pi\)&lt;/span&gt; high and &lt;span class="math"&gt;\(\log(r)\)&lt;/span&gt; wide. &lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(z \rightarrow \log(\frac{z}{r1})\)&lt;/span&gt; takes the annulus to a similar strip: points inside the annulus are transformed into points within a strip &lt;span class="math"&gt;\(2 \pi\)&lt;/span&gt; high and &lt;span class="math"&gt;\(\log(\frac{r2}{r1})\)&lt;/span&gt; wide.&lt;/p&gt;
&lt;p&gt;The inverse transformation is &lt;span class="math"&gt;\(z \rightarrow e^{z} \cdot r1\)&lt;/span&gt;. Transforming our coordinate system this way &lt;em&gt;before&lt;/em&gt; we draw the circle will have the same effect as drawing the circle and then transforming it forward by the &lt;span class="math"&gt;\(\log\)&lt;/span&gt; transformation.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*4.0; // just so we can see more
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}"&gt;&lt;noscript&gt;&lt;pre&gt;float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*4.0; // just so we can see more
    z = cMul(cExp(z),vec2(r1,0.0));
    return circles(z,r1,r2);
}&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;

&lt;p&gt;And we obtain the strip we were looking for. But wait, it's infinitely tall! What's going on? The complex &lt;span class="math"&gt;\(\log\)&lt;/span&gt; is a multi-valued function: it maps the annulus to an infinite number of strips, all stacked up. It's defined as the inverse of the exponential function, and the exponential function actually takes points inside the infinitely tall ribbon to the annulus over and over again.&lt;/p&gt;
&lt;p&gt;So, now we're in what I call &lt;span class="math"&gt;\(\exp\)&lt;/span&gt;-space. The rules are a bit different here. Just looking at the strip we have, left and right correspond to "in-out" in ordinary space; up and down correspond to rotating around the origin. This is the property that will generate the telescoping copies we want! We tile the ribbon horizontally in &lt;span class="math"&gt;\(\exp\)&lt;/span&gt;-space using the modulo function:&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*4.0; 
    // 2. Tile the strips
    z.x = mod(z.x,log(r2/r1)); 
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}"&gt;&lt;noscript&gt;&lt;pre&gt;float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*4.0; 
    // 2. Tile the strips
    z.x = mod(z.x,log(r2/r1)); 
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}&lt;/pre&gt;&lt;/noscript&gt;&lt;/div&gt;

&lt;p&gt;This looks like the wrong order, but since we're actually building an inverse function, later transformations need to be applied above earlier ones. Let's use &lt;span class="math"&gt;\(\log\)&lt;/span&gt; to leave &lt;span class="math"&gt;\(\exp\)&lt;/span&gt;-space and see what our infinite tiling achieved. Even though above I said that the complex logarithm was a multi-valued function, we can define a version that acts like an ordinary function and returns a single value (the &lt;a href="https://en.wikipedia.org/wiki/Principal_value"&gt;principal value&lt;/a&gt;).&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*1.0; // Play with this to zoom
    // 3. Take the tiled strips back to ordinary space.
    z = cLog(z); 
    // 2. Tile the strips
    z.x = mod(z.x,log(r2/r1));
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}"&gt;&lt;noscript&gt;&lt;pre&gt;float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*1.0; // Play with this to zoom
    // 3. Take the tiled strips back to ordinary space.
    z = cLog(z); 
    // 2. Tile the strips
    z.x = mod(z.x,log(r2/r1));
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}&lt;/noscript&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Wow! We're well on our way. Each strip is transformed into another annulus, one nested inside the other. We can zoom in or out as much as we want, and there will always be another nesting annulus. We are sure of this because of the infinite tiling in &lt;span class="math"&gt;\(\exp\)&lt;/span&gt;-space.&lt;/p&gt;
&lt;p&gt;By rotating and scaling the strips in &lt;span class="math"&gt;\(\exp\)&lt;/span&gt;-space, we can create the spiral effect we are looking for. The transformation code here is just an inversion of the Jos Ley's transformation in his step (2): &lt;span class="math"&gt;\(z \rightarrow \frac{z}{e^{\theta i} \cdot cos(\theta)}\)&lt;/span&gt;. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*4.0; 
    // 3. Scale and rotate the strips
    float scale = log(r2/r1);
    float angle = atan(scale/(2.0*PI));
    z = cDiv(z, cExp(vec2(0,angle))*cos(angle)); 
    // 2. Tile the strips
    z.x = mod(z.x,scale);
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}"&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class="math"&gt;\(a+bi\)&lt;/span&gt; and &lt;span class="math"&gt;\(a+(b+2\pi)i\)&lt;/span&gt; are transformed to the same point under the complex logarithm. After this rotation and scale, the top-right corner of each strip is exactly &lt;span class="math"&gt;\(2\pi\)&lt;/span&gt; above the bottom-left. After the logarithmic transformation, the upper right corner of each strip will coincide with the bottom-left corner of the previous. The inner circle and outer circle will connect! The result is a smooth spiral. &lt;/p&gt;
&lt;p&gt;Try commenting out the tiling in the following example. You'll see how the rotation in &lt;span class="math"&gt;\(\exp\)&lt;/span&gt; space has "torn" the annulus along the positive real axis. The tear is (I believe) a visual &lt;a href="https://en.wikipedia.org/wiki/Branch_point#Complex_logarithm"&gt;branch cut&lt;/a&gt;. The tiling repairs the tear by bringing in an infinite number of sheets that extend across all of the branches of the complex logarithm. I've been attempting to teach myself &lt;em&gt;just enough&lt;/em&gt; complex analysis to understand this part, so my explanation may not in fact make any sense. At least, with some playing around, you can see how it works geometrically. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.2;
float r2 = 0.7;
vec3 color(vec2 z) {
    z = z*10.0; 
    // 4. Take the tiled strips back to ordinary space.
    z = cLog(z);
    // 3. Scale and rotate the strips
    float scale = log(r2/r1);
    float angle = atan(scale/(2.0*PI));
    z = cDiv(z, cExp(vec2(0,angle))*cos(angle)); 
    // 2. Tile the strips
    z.x = mod(z.x,scale);
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return circles(z,r1,r2);
}"&gt;&lt;/div&gt;

&lt;p&gt;Now we have a Droste effect put together, we can abstract it out to a function. Rather than drawing an annulus, we're going to draw a simple pattern to show what the effect does to more arbitrary shapes. Notice that with a small r1 it begins to resemble the Print Gallery, except the twist is going in the other direction. &lt;/p&gt;
&lt;p&gt;Only now does the most important property of this transformation become apparent: it is &lt;a href="https://en.wikipedia.org/wiki/Conformal_map"&gt;conformal&lt;/a&gt;, which means it preserves angles locally.   Where two lines met at right angles before the transformation, they still do after being Drostified. This means that pictures transformed this way are very likely to remain recognizable.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float r1 = 0.1;
float r2 = 2.0;
vec2 droste(vec2 z) {
    // 4. Take the tiled strips back to ordinary space.
    z = cLog(z);
    // 3. Scale and rotate the strips
    float scale = log(r2/r1);
    // Negate the angle to twist the other way
    float angle = atan(scale/(2.0*PI));
    z = cDiv(z, cExp(vec2(0,angle))*cos(angle)); 
    // 2. Tile the strips
    z.x = mod(z.x,scale);
    // 1. Take the annulus to a strip
    z = cExp(z)*r1;
    return z;
}
vec3 color(vec2 z){
    z = droste(z);
    // Draw anything you want below!
    z = sin(z*20.0)*10.;
    return vec3(z.x*z.y);
}
"&gt;&lt;/div&gt;

&lt;p&gt;In the next post(s), I'll explore how to handle (Drostifying a square)[http://roy.red/infinite-regression-.html#infinite-regression]. I'll also show how to generalize the effect by adjusting how much it twists, how many arms the spiral has, and more.&lt;/p&gt;
&lt;p&gt;As a reward for making it all the way to the end, here's an example of what you can do with the Droste effect! On the left is the original animation, and on the right the Droste transformation has been applied.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;canvas class="glslCanvas" style:"margin: auto;" data-fragment-url="../shaders/gears.frag" width="500" height="250"&gt;&lt;/canvas&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry></feed>