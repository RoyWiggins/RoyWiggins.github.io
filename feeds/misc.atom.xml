<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Roy.red</title><link href="http://roy.red/" rel="alternate"></link><link href="http://roy.red/feeds/misc.atom.xml" rel="self"></link><id>http://roy.red/</id><updated>2016-07-20T20:15:16-07:00</updated><entry><title>Infinite Regression: Many Pictures From One Function</title><link href="http://roy.red/infinite-regression-.html" rel="alternate"></link><updated>2016-07-20T20:15:16-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-07-20:infinite-regression-.html</id><summary type="html">&lt;p&gt;&lt;a href="http://roy.red/images/regular-division-of-the-plane-vi.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/regular-division-of-the-plane-vi.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was interested in trying to imitate Escher's image, "Regular Division of the Plane IV", which depicts an infinite regression of tiles towards the edge. In doing so, I realized I'd re-written a function I'd seen elsewhere- in &lt;a href="http://www.gamedev.net/topic/590070-glsl-droste"&gt;generating Droste images&lt;/a&gt;- but hadn't looked at closely to understand what it could be used for. It's actually quite powerful and can be used to explore several of Escher's prints! So in this post I am going to play with this function and show how you can manipulate it to generate interesting scaling tilings, as well as a square Droste image (&lt;a href="/droste-.html"&gt;see previous&lt;/a&gt;). As usual there's an (over?)abundance of live code you can fiddle with.&lt;/p&gt;
&lt;p&gt;The equation is extremely simple:&lt;/p&gt;
&lt;div class="math"&gt;$$f(x) = 2^{\lfloor \log_2{x}\rfloor}$$&lt;/div&gt;
&lt;p&gt;It turns out it has the exact property we need to draw this sort of image. It's plotted below; &lt;a href="https://www.desmos.com/calculator/4umgsbyrnk"&gt;see also in Desmos&lt;/a&gt;. It builds a staircase that grows a lot like &lt;span class="math"&gt;\(y = x\)&lt;/span&gt;, except that it has discrete jumps at every integer power of two. It also preserves some of the &lt;em&gt;dilational symmetry&lt;/em&gt; of &lt;span class="math"&gt;\(y=x\)&lt;/span&gt;: you can scale the whole thing by a power of two and you get the same plot. Ignoring the coloring, an extension of Escher's print across the whole half-plane would have the same exact symmetry.&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="float plot(vec2 st, float y){
  return  smoothstep( y-0.02, y, st.y) - 
          smoothstep( y, y+0.02, st.y);
}
float function(float x){
    return exp2(floor(log2(x)));
}
vec3 color(vec2 z) {
    z = (z+1.)*vec2(2.,1.02);
    return vec3(.9-plot(z,function(z.x)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Between &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; and &lt;span class="math"&gt;\(1.0\)&lt;/span&gt;, &lt;span class="math"&gt;\(f(x) = 0.5\)&lt;/span&gt;, and so forth, for adjacent powers of two:&lt;/p&gt;
&lt;div class="math"&gt;$$f(x) = 2^{n} \{ 2^n \leq x &amp;lt; 2^{n+1}\}$$&lt;/div&gt;
&lt;p&gt;This is exactly what we need. If you go back and look at the Escher print, there's a series of rows of tiles; each row is exactly half as tall as the one above, and the tiles within it are half as big. &lt;/p&gt;
&lt;p&gt;To start with, we need lots of copies of our image. Here a circle radius &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; is used to tile the plane.&lt;/p&gt;
&lt;div  style='clear:right' class="codeAndCanvas" data="float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    z += 1.;
    // fract == modulo 1.0
    return vec3(circle(fract(z)));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;We then use &lt;span class="math"&gt;\(f(z.x)\)&lt;/span&gt; as a scaling factor, and out pops the Escher-type tiling that I was interested in at the beginning! Notice how in this picture, each "column" of circles lines up with a "step" of the plot of &lt;span class="math"&gt;\(f\)&lt;/span&gt; above.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float f(float x){
    return exp2(floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    z += 1.;
    float scale = f(z.x);
    z /= scale;
    return vec3(circle(fract(z)));
}"&gt;&lt;/div&gt;

&lt;p&gt;But once we've got this function, we can use it to draw more things! For instance, something reminiscent of Escher's &lt;a href="http://www.wikiart.org/en/m-c-escher/smaller-smaller"&gt;Smaller and Smaller&lt;/a&gt;. Instead of dividing by &lt;code&gt;scale&lt;/code&gt;, we multiply by the reciprocal (multiplication is faster). The input to &lt;span class="math"&gt;\(f\)&lt;/span&gt; is calculated as the larger of &lt;span class="math"&gt;\(\left|x\right|\)&lt;/span&gt; and &lt;span class="math"&gt;\(\left|y\right|\)&lt;/span&gt; which produces a characteristic square pattern. The mathematics of &lt;em&gt;that&lt;/em&gt; is either fiddly or obvious, depending on whether you've seen it before, so I'm going to skip over the derivation. &lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="//'Smaller and Smaller'
float f(float x){
    return exp2(-floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    vec2 a_z = abs(z);
    float scale = f(max(a_z.x,a_z.y));
    return vec3(circle(fract(z*scale)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Looking at this, I saw the obvious similarity to Droste images; it is a Droste image, except that we've got extra copies of the original. "Extra copies" is a good problem to have, because we're just a constant or two away from a classic square Droste picture. &lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x){
    return exp2(-floor(log2(x))-1.); // here's the change
}
vec3 texture(vec2 z){
    return texture2D(u_tex0,z*0.5+0.5).xyz;
}
vec3 color(vec2 z) { 
    vec2 a_z = abs(z);
    float scale = f(max(a_z.x,a_z.y));
    return texture(z*scale);
}"&gt;&lt;/div&gt;

&lt;p&gt;And now we can apply Escher's twist that &lt;a href="/droste-.html"&gt;I implemented previously&lt;/a&gt;. This time though, we don't need to use any modulo function, since we already have our infinitely nesting copies. This makes the transformation nearly a one-liner.&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x){
    return exp2(-floor(log2(x)));
}
mat2 rotate(float a){
    return mat2(cos(a),-sin(a),sin(a),cos(a));
}
vec3 texture(vec2 z){
    return texture2D(u_tex0,z*.5+0.5).xyz;
}
vec3 color(vec2 z) { 
    float angle = atan(log(2.)/(2.0*PI));
    z = cExp(cDiv(cLog(z), cExp(vec2(0,angle))*cos(angle))); 
    vec2 a_z = abs(z);
    z *= f(max(a_z.x,a_z.y)*2.);
    return texture(z);
}"&gt;&lt;/div&gt;

&lt;p&gt;The obvious generalization to &lt;span class="math"&gt;\(f\)&lt;/span&gt; is to allow an arbitrary exponent, and it turns out it also generalizes our Droste too, adjusting how deep each copy is created. &lt;/p&gt;
&lt;div class="math"&gt;$$f(x,n) = n^{\lfloor \log_n{x}\rfloor}$$&lt;/div&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x,float n){
    return pow(n,-floor(log(x)/log(n)));
}
mat2 rotate(float a){
    return mat2(cos(a),-sin(a),sin(a),cos(a));
}
vec3 texture(vec2 z){
    return texture2D(u_tex0,z+0.5).xyz;
}
vec3 color(vec2 z) {
    float ratio = 5.264;
    float angle = atan(log(ratio)/(2.0*PI));
    z = cExp(cDiv(cLog(z), cExp(vec2(0,angle))*cos(angle)));
    vec2 a_z = abs(z);
    z *= f(max(a_z.x,a_z.y)*2.,ratio);
    return texture(z/ratio);
}"&gt;&lt;/div&gt;

&lt;p&gt;And with some more constants and an adjustment, there's a version of Escher's &lt;a href="http://www.wikiart.org/en/m-c-escher/square-limit?utm_source=returned"&gt;Square Limit&lt;/a&gt; hidden inside here as well!&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="float f(float x){
    return exp2(-floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    // Arrived at by motivated guesswork
    z = (z+1.)*.75;
    vec2 a_z = .75-abs(z-.75);
    return vec3(circle(fract(z*f(min(a_z.x,a_z.y)))));
}"&gt;&lt;/div&gt;

&lt;p&gt;That's all for now! If you want to have some more fun with Droste images, check out my previous post on &lt;a href="/fractal-droste-images-.html"&gt;fractally-distorted drostes&lt;/a&gt;. Or perhaps take a leap into the &lt;a href="/slitscan-.html"&gt;Time Tunnel&lt;/a&gt;!&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Fun with interference patterns</title><link href="http://roy.red/interference-.html" rel="alternate"></link><updated>2016-05-04T21:04:56-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-05-04:interference-.html</id><summary type="html">&lt;p&gt;Ordinary trigonometric functions can produce really interesting, structured patterns if you use sufficiently large numbers. There's nothing fancy happening here, but at different scales and with different constants, the result can change quite drastically. Try zooming in (&lt;code&gt;z = z * 0.01&lt;/code&gt; for instance) and you'll see that it's just bands of white and black. It's only when you zoom out that creeping bands moving in crazy directions appear.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 z) {
    z = z * 1.;
    float r=length(z);
    return vec3(sin(cos(r)*r*(u_time+1000.)*10.0));
}"&gt;&lt;/div&gt;

&lt;p&gt;I'm fairly sure this is a straightforward consequence of interference. The square grid of pixels is sampling the underlying equation at regular intervals. The result is a kind of &lt;a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern"&gt;moiré pattern&lt;/a&gt;. For photography and graphics applications aliasing is Bad News, but you can harness it to produce interesting patterns. &lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;Anyway, math aside, you can pretty much just start messing with constants and mushing trigonometric functions together here and see what happens. It inherits some of the rotational symmetry of the underlying pattern, so we end up with something that isn't completely mush. Plugging the time variable into a periodic function like &lt;code&gt;sin&lt;/code&gt; lets us quite easily find interesting loops, ripe for the giffing. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    pt = pt * 1.6;
    float r = length(pt);
    float stime = 4.*sin(u_time * 2. * PI)+100.;
    return vec3(r+cos(cos(r*r*100.)*stime));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;My current "fancy" way to gif something is to render it in &lt;a href="https://syntopia.github.io/Fragmentarium/index.html"&gt;Fragmentarium&lt;/a&gt; and take the resulting pngs and run them through &lt;a href="https://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt;'s &lt;code&gt;convert&lt;/code&gt; utility. This is a bit fiddly, so often I just use my favorite program: &lt;a href="http://blog.bahraniapps.com/gifcam/"&gt;GifCam&lt;/a&gt;! It's a tiny utility that records gifs directly off your screen. It certainly won't produce the best, smallest, lowest-artifact gif, but it's easy to use and the results aren't half bad!&lt;/p&gt;
&lt;p&gt;&lt;img width="250" src="/images/interference-1.gif"/&gt;
&lt;img width="250" src="/images/circles_m.gif"/&gt;
&lt;img width="250" src="/images/mandala2.gif"/&gt;&lt;/p&gt;</summary></entry></feed>