<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Roy.red</title><link href="http://roy.red/" rel="alternate"></link><link href="http://roy.red/feeds/misc.atom.xml" rel="self"></link><id>http://roy.red/</id><updated>2017-04-12T15:46:52-07:00</updated><entry><title>Folding Animated Hyperbolic &amp; Spherical Tilings</title><link href="http://roy.red/folding-tilings-.html" rel="alternate"></link><published>2017-04-12T15:46:52-07:00</published><updated>2017-04-12T15:46:52-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2017-04-12:folding-tilings-.html</id><summary type="html">&lt;p&gt;In a &lt;a href="/folding-the-koch-snowflake-.html#folding-the-koch-snowflake"&gt;previous post&lt;/a&gt;, I talked about generating interesting pictures by iterated folding operations. In this post I'm going to use another type of fold to draw both hyperbolic and spherical tilings. If you are already familiar with hyperbolic geometry and tilings, skip the next few paragraphs! There's code down at the bottom.&lt;/p&gt;
&lt;p&gt;In order to simplify what we're talking about, we can limit ourselves to tilings of right-angled triangles. In the Euclidean plane, there are two ways to tile the plane this way. One can be identified with a regular tiling of squares, and the other with a regular tiling of hexagons (or equilateral triangles). &lt;/p&gt;
&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;
&lt;a href="https://en.wikipedia.org/wiki/Spherical_polyhedron#/media/File:Spherical_pentakis_dodecahedron.png"&gt;&lt;img style="float:right;" width="200px" src="http://roy.red/images/spherical-dodecahedron.png"/&gt;&lt;/a&gt;&lt;br/&gt;A dodecahedral tiling&lt;/div&gt;

&lt;p&gt;There are no other ways to tile the plane like this. But instead of tiling the Euclidean plane, we can look toward other geometries. One you are probably familiar with is spherical geometry: instead of drawing lines on a flat plane, we draw arcs on a sphere. Inside the spherical geometry, portions of &lt;a href="https://en.wikipedia.org/wiki/Great_circle"&gt;great circles&lt;/a&gt; are actually straight lines. While things look a bit different, you can still build right triangles, and tile the sphere with them. On the sphere, there are few &lt;a href="https://en.wikipedia.org/wiki/Spherical_polyhedron"&gt;more tilings&lt;/a&gt;! &lt;/p&gt;
&lt;p&gt;In a sense, the spherical geometry is bending every straight line a bit towards every other straight line. If you extend a line segment, it will intersect every other line, "around the back" of the sphere. You can convince yourself of this with some patient time with a globe.&lt;/p&gt;
&lt;hr style="clear:right;"/&gt;

&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;
&lt;a href="https://upload.wikimedia.org/wikipedia/commons/f/f3/Hyperboloid-2s.svg"&gt;&lt;img style="float:right;" src="http://roy.red/images/hyperboloid.svg" height="200px"/&gt;&lt;/a&gt;&lt;br/&gt;Two views of a hyperboloid&lt;/div&gt;

&lt;p&gt;There's another geometry that goes in the "other direction": it bends every straight line away from every other. This is the mysterious &lt;a href="https://en.wikipedia.org/wiki/Hyperbolic_geometry"&gt;hyperbolic geometry&lt;/a&gt;. It's called hyperbolic by analogy to the spherical geometry: you can draw lines as parts of hyperbolas, on one sheet of a hyperboloid.&lt;/p&gt;
&lt;p&gt;In this geometry, there are even more tilings (an infinite number, in fact). You can fit as many identical right triangles around a vertex as you like, and the resulting polygon can tile the plane. There is, in a sense, "more space" to move around in. If you draw two straight lines, they may intersect- but they might not intersect at all, no matter how far you extend them. There's 'more' space for the lines to go, and they tend to bend away from each other.&lt;/p&gt;
&lt;p&gt;While these geometries both "live" in three-dimensional objects (spheres and hyperboloids) they can be modeled in the plane. In the case of spherical geometry, you can simply &lt;a href="https://en.wikipedia.org/wiki/Stereographic_projection"&gt;stereographically project&lt;/a&gt; the sphere onto the plane. Straight lines (arcs) on the sphere become circles in the plane. Further away from the origin, objects look bigger (even if they're the same size on the sphere). &lt;/p&gt;
&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;&lt;a href="
https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model#/media/File:HyperboloidProjection.png
"&gt;&lt;img src="http://roy.red/images/poincare-projection.png" height="200px"/&gt;&lt;/a&gt;&lt;br/&gt;Poincaré projection&lt;/div&gt;

&lt;p&gt;The model we are using of hyperbolic geometry is called the Poincaré Disk. It gathers the entirety of the hyperbolic space into a circle in the plane. It is formed similarly to the stereographic projection: it projects points on the hyperboloid down onto the plane by casting a ray from a point underneath.&lt;/p&gt;
&lt;div style="clear:right;"/&gt;
&lt;div style ="float:right; text-align: right; font-size: 0.8em; color:gray"&gt;&lt;a href="https://en.wikipedia.org/wiki/Poincar%C3%A9_disk_model#/media/File:Droites_disquePoincaré.svg"&gt;&lt;img src="http://roy.red/images/poincare.svg" height="200px"/&gt;&lt;/a&gt;&lt;br/&gt;Three hyperbolic lines&lt;/div&gt;

Straight lines (hyperbolas) in the hyperbolic geometry are drawn as circles in the plane. Further away from the origin (and closer to the edge of the disk), objects look smaller (even though they're the same size on the hyperboloid). Angles are preserved, so (for instance) two lines that appear to be perpendicular when measured by Euclidean standards actually are perpendicular. 

&lt;hr style="clear:right;"/&gt;

Okay. Long-winded math over, let's start folding things. Like the previous post, we're going to be mirroring pixels across a boundary. In this case, we are going to keep track of the number of times each point is actually moved by a folding operation. If a point is folded, we increment a variable; once we're done, we use the value to color the pixel.
&lt;br/&gt;&lt;br/&gt;
To begin, we do two folds across the X and Y axes. You can adjust the orientation of the fold axes to see how it behaves. The upper-right quadrant stays black because points there are never moved. Points in the lower left are folded twice, and so are also black. The other two are folded exactly once, so they turn gray.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="void fold(inout vec2 p, vec2 dir,inout int n){
    float dt = dot(p,dir);
    if (dt&lt;0.) {
        p-=2.*dt*dir;
        n++;
    }
}
vec3 color(vec2 pt) {
    int n=0;
    fold(pt,normalize(vec2(1,0)),n);
    fold(pt,normalize(vec2(0,1)),n);
    return vec3(fract(float(n)/2.));
}"&gt;&lt;/div&gt;

In the Poincaré disk model of hyperbolic geometry, a straight line is drawn as a portion of a generalized circle (generalized, because the center of the circle can be "at infinity", and it looks like a line through the origin). To reflect across a hyperbolic line you actually invert across the circle. Inside the hyperbolic geometry, distances aren't affected by inversion, even if they look like they are in our model. So, using the circle inversion idea, we define a fold "across" a circle. If a point is outside the circle, it is unaffected, but if it is inside, it is "folded" to the outside with a circle inversion.
&lt;br/&gt;&lt;br/&gt;
Here, we are folding across two lines and a circle. From the point of view of the Poincaré model, all three folds are across straight lines (or, alternatively, there are three circle inversions, and two of the circles have a center at infinity). You could do this with three suitably chosen circles, too.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="vec2 cInverse(vec2 z, vec2 center, float radius){
    z -= center;
    return z*radius*radius/dot(z,z) + center;
}
void fold_circle(inout vec2 z, vec2 c, float r, inout int n) {
    if (distance(z,c)&gt;r) return;
    z = cInverse(z,c,r);
    n++;
}
vec3 drawCircle(vec2 z,vec2 c,float r) {
    return vec3(smoothstep(distance(z,c)-r,.01,0.));
}
vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent=vec2(1); float invRad=1.122;
    vec3 color = drawCircle(pt,invCent,invRad);
    fold(pt,vec2(1,0),n);
    fold(pt,vec2(0,1),n);
    fold_circle(pt,invCent,invRad,n);
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;

Now if we just apply the folds a few more times, a new picture starts to emerge: it's a Poincaré disk! These three folds are actually generating a hyperbolic geometry. Adjust the number of iterations to see how the circle inversions successively copy and smoosh the shapes into a steady progression towards the perimeter. These shapes are all right triangles, and they are all the same shape and size.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="void doFolds(inout vec2 z,vec2 c,float r,inout int n) {              
    fold(z,vec2(1,0),n);
    fold(z,vec2(0,1),n);
    fold_circle(z,c,r,n);
}
vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent=vec2(1); float invRad=1.122;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;

In the Poincaré disk model, not every arc is a straight line: it has to be perpendicular to the edge of the disk. So you'll notice that as you move the inverting circle, the generated disk shifts and changes shape. With some more math, you can work back from the disk to find circles that will generate it. Many choices of circle don't result in a uniform tiling at all. More math can tame this as well, and generate tilings based on how many tiles should fit around each vertex. 
&lt;br/&gt;&lt;br/&gt;
You might have noticed that the picture changes quite a lot if the inverting circle actually includes the origin. The tiling suddenly doesn't approach a limit: it fills the entire plane with a finite number of tiles. The geometric reason is simply that, if you start inside a circle, the inversion will make the tile bigger and bigger, rather than smaller and smaller (like it did when the origin was outside the circle). The result here is actually a model of spherical geometry, and we've generated a tiling of the sphere. Conveniently, reflections in spherical geometry are also modeled by circle inversions in the plane.

&lt;div style='clear:right'&gt;&lt;/div&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt *= 2.;
    vec2 invCent=vec2(1); float invRad=2.00;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;3;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

When the origin is exactly on the circumference of the circle, we get a third case. There are an infinite number of tiles, but unlike the hyperbolic case, they march towards the origin. This looks pretty unfamiliar. It's definitely not spherical, and it doesn't look much like the hyperbolic pictures we had either. 

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    vec2 invCent=vec2(sqrt(.5)); float invRad=1.;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

Surprise! It's actually a circle inverted flat tiling. If we invert our coordinate system, we can recover a flat tiling. Remember than this was generated by inverting around a circle with a circumference that intersected the origin. Circles through the origin are straight lines under circle inversion, and vice versa, so that's why iterating the inversion through our circle generated the inverse of a flat tiling. So an ordinary reflection across a line can be thought of as a special case of an inversion across a circle.

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt = cInverse(pt*3.,vec2(0),1.);
    vec2 invCent=vec2(sqrt(.5)); float invRad=1.;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

Now for the magic bit: we can wobble our circle back and forth to generate all three types of tiling! From this perspective, flat Euclidean geometry can be seen quite naturally as sitting on the knife-edge between spherical and hyperbolic.  It transitions between &lt;a href="https://en.wikipedia.org/wiki/Orbifold_notation#/media/File:H2checkers_245.png"&gt;[4,5]&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Tetrakis_square_tiling#Symmetry"&gt;[4,4]&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Octahedral_symmetry"&gt;[4,3]&lt;/a&gt; tilings (in &lt;a href="https://en.wikipedia.org/wiki/Coxeter_notation"&gt;Coxeter notation&lt;/a&gt;).

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt = cInverse(pt*3.,vec2(0),1.);
    vec2 invCent=vec2(sqrt(.5));
    invCent.x += mix(-0.054,0.1,sin(u_time));
    float invRad=1.;
    vec3 color = drawCircle(pt,invCent,invRad);
    for (int i=0;i&lt;10;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    color *= hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
    return color;
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

You can do the same with the other flat tiling; here,  it transitions between &lt;a href="https://en.wikipedia.org/wiki/Icosahedral_symmetry"&gt;[5,3]&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Orbifold_notation#/media/File:Tile_V46b.svg"&gt;[6,3]&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/3-7_kisrhombille#Symmetry"&gt;[7,3]&lt;/a&gt; tilings.

&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    int n=0;
    pt = cInverse(pt*4.5,vec2(0),1.);
    vec2 invCent=vec2(sqrt(3.)/2.,.5);
    invCent.x += mix(-0.011,0.035,sin(u_time));
    float invRad=1.;
    for (int i=0;i&lt;20;i++) {
        doFolds(pt,invCent,invRad,n);
    }
    return hsv2rgb(vec3(fract(float(n)/2.)/4.,1.,1.-float(n)/40.));
}"&gt;&lt;/div&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;


That's all for now. In my next post I will explore translating, rotating, and generally splashing about inside hyperbolic geometry. In the meantime, feel free to play with hyperbolic tilings &lt;a href="http://roy.red/editor/#../shaders/poincare-disk-fold.frag"&gt;in the editor here&lt;/a&gt;. If you want to play with a more fully-featured environment, I recommend this &lt;a href="http://gratrix.net/tile/tile.html"&gt;tiling generator&lt;/a&gt;.</summary></entry><entry><title>Building Escher's Square Limit in Pixels</title><link href="http://roy.red/building-eschers-square-limit-.html" rel="alternate"></link><published>2016-12-31T19:16:05-08:00</published><updated>2016-12-31T19:16:05-08:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-12-31:building-eschers-square-limit-.html</id><summary type="html">&lt;p&gt;&lt;a href = "https://www.wikiart.org/en/m-c-escher/square-limit?utm_source=returned&amp;utm_medium=referral&amp;utm_campaign=referral"&gt;&lt;img style="float: right;" width="300" src="http://roy.red/images/square-limit.jpg"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I've been fascinated by M.C. Escher's "Square Limit" print for a while. In the hopes of understanding it better I decided to try to generate my own square limit images. Drawing a Square Limit was done as early as 1981, more recently in &lt;a href="https://shashi.github.io/ijulia-notebooks/funcgeo/"&gt;Julia&lt;/a&gt;, using a functional approach. I didn't find these methods satisfying, partly because they relied on directly drawing each motif iteratively, even if they are using the symmetries of the piece. &lt;/p&gt;
&lt;p&gt;I built a way to render square limits with a GLSL fragment shader and in this post I'm going to walk through most of it and explain how it works. For a shader primer, check out the &lt;a href="http://thebookofshaders.com/"&gt;Book of Shaders&lt;/a&gt;. The important thing to know is that to write a fragment shader, you build a function that takes a location (in our case, of a pixel) and returns a color. All the code here is "live", though changes you make in each box will not cascade down to the subsequent ones- it's not a proper live coding environment. A full version of the code is linked at the end.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/bird-shape-2.png"/&gt;&lt;/p&gt;
&lt;p&gt;To start, we're going to to the fiddly bit, drawing the motif itself. I'm going to use a simplified motif of a bird borrowed from &lt;a href="http://www.tess-elation.co.uk/self-similar-tessellations"&gt;David Bailey&lt;/a&gt;. Looking at the simplified motif, it's more clear what symmetries exist. I've circled the four regions of the border that are related by by scaling, flipping, and rotation. The most flexible way to draw the motif is to exploit these symmetries. &lt;/p&gt;
&lt;p&gt;If you look closely at the original print, you'll notice that while it looks like one motif scaled and rotated many times, there are actually regular distortions in the shapes of the fish. For instance, where three fish come together, the fins are adjusted so they have threefold rotational symmetry, rather than coming together in a T shape. My square limit doesn't accurately capture these, but then neither do any of the other computer-generated square limits that I've seen. The way mine is drawn, it would not be too hard to manually adjust the motifs in these places but I'm going to leave it for the future.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;First, we draw one of the marked regions. It may not be immediately obvious why this draws a bump. It's just $y = -|x+.5|+.5 $ rewritten as an &lt;a href="https://www.desmos.com/calculator/t8yifdzokv"&gt;implicit formula&lt;/a&gt; so we can assign each pixel a value directly. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="float bird_shape(vec2 z){
    return 10.*(z.y+min(0.,abs(z.x+.5)-.5)+2.);
}
vec3 color(vec2 z) {
    return vec3(bird_shape(z*2.));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;Next we need to rotate and scale this shape three more times to form the bird shape. The shapes are composed together using &lt;code&gt;min&lt;/code&gt;, which may seem strange at first glance. The edge of our shape is defined by &lt;span class="math"&gt;\(f(z) = 0\)&lt;/span&gt;. If &lt;span class="math"&gt;\(h = min(f,g)\)&lt;/span&gt;, then &lt;span class="math"&gt;\(h(z) \leq 0\)&lt;/span&gt; when either &lt;span class="math"&gt;\(f(z)\)&lt;/span&gt; or &lt;span class="math"&gt;\(g(z)\)&lt;/span&gt; is. And on the other hand, &lt;span class="math"&gt;\(h(z) &amp;gt; 0\)&lt;/span&gt; if and only if &lt;span class="math"&gt;\(f(z) \gt 0\)&lt;/span&gt; and &lt;span class="math"&gt;\(g(z) \gt 0\)&lt;/span&gt;. So the shape we see after composing them with &lt;code&gt;min&lt;/code&gt; is the intersection- a logical AND- of the two original shapes. We're carving the plane into two regions, one inside the bird and one outside.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="float bird(vec2 z){
    float color = bird_shape(z)*smoothstep(-0.001,0.001,-z.x);
    // rot 180
    color -= bird_shape(z*mat2(-1,0,0,-1)+vec2(0,-4))*smoothstep(0.,0.001,z.x);
    z *= mat2(1.,1.,-1.,1.);// rot 45, scale
    z.y += 4.;
    z = vec2(z.x,-z.y);
    color = min(color,bird_shape(z*.5));
    z *= mat2(0.,1.,-1.,0.);
    z += 4.;
    color = min(color,-bird_shape(-z*.5));
    return smoothstep(-0.001,.001,color);;
}
vec3 color(vec2 z) {
    return vec3(bird(z*2.-vec2(0,1)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Now we can build the three-bird square that is the heart of the image. This needs to be drawn various times with various different colors, so this function takes parameters to adjust which colors are drawn. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="const vec3 light = vec3(0.995,0.964,0.573);
const vec3 mid = vec3(0.995,0.663,0.261);
const vec3 dark = vec3(0.995,0.390,0.314);
vec3 colors(int n,bool cycleDir){
    n = n &gt; 2? n-3: n; // modulo (int x) doesn't exist, so
    if (!cycleDir) n = 2 - n;
    return n == 2? mid: n == 1? dark: light;
}
vec3 three_birds(vec2 z, int t,bool s){
    vec3 color;
    z = z.yx;
    color = bird(z)*colors(t,s);
    color = mix(color,colors(1+t,s),bird(z*mat2(0,-1,1,0)));
    z = (z+vec2(-2.,-2.))*mat2(-.5,.5,.5,.5);
    color = mix(color,colors(2+t,s),bird(z));
    return color;
}
vec3 color(vec2 z) {
    return vec3(three_birds(z*3.,1,true));
}"&gt;&lt;/div&gt;

&lt;p&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/simple-square-limit.png"/&gt;&lt;/p&gt;
&lt;p&gt;Now, we're going to switch gears. We don't want to draw every single bird by hand, so we're going to zoom out to look at the whole design. In a &lt;a href="/infinite-regression-.html#"&gt;previous post&lt;/a&gt;, I found a transformation that will "shatter" a square tile into an infinite regression inside a large square; see the last example in that post to understand how it works better. You can also play with the transformation in the &lt;a href="https://www.desmos.com/calculator/rju8punri0"&gt;Desmos online graphing calculator&lt;/a&gt;.&lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href="http://roy.red/images/colored-square-limit.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/colored-square-limit.jpg"/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rather than draw the same tile at each scale, to draw a proper square limit, some of the constituent tiles are going to necessarily be different from each other. At the center, for example, four motifs come together; along the diagonals, four motifs come together as well, though the coloring is different.&lt;/p&gt;
&lt;p&gt;To orient ourselves, we're just going to start with the scaling-transform and mask off each of the regions. We calculate the scaling factor twice, once in the &lt;span class="math"&gt;\(x\)&lt;/span&gt; and once in the &lt;span class="math"&gt;\(y\)&lt;/span&gt; direction. The magenta squares lie where the scaling factors in both directions are equal. The square in the middle has a scaling factor of two, so we will color that red with a special case. The green and yellow regions are distinguisable by which of &lt;span class="math"&gt;\(x\)&lt;/span&gt; and &lt;span class="math"&gt;\(y\)&lt;/span&gt; are greater.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec2 scale_f(vec2 x){
    return exp2(-floor(log2(x)));
}
vec3 color(vec2 z) {
    z = (z+1.)*.75; 
    vec2 scale = scale_f(.75-abs(z-.75));
    if (scale.x == scale.y) {
        if (scale.x == 2.) // Center square
            return vec3(1,0,0);
        return vec3(1,0,1); // 'Corner' squares
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return vec3(0,1,0);
    } else { //scale.x &gt; scale.y
        // Left and right
        return vec3(1,1,0); 
    }
}"&gt;&lt;/div&gt;

&lt;p&gt;Here's the center tile. The corners of the "diamond" will get cropped down into a square flush around the central four birds. Four birds around the edge appear to be superfluous, but with a different motif they won't be, so it's much easier just to leave them in.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 center_tile(vec2 z){
    vec3 color = vec3(0);
    z = z.yx;
    z = z*4.-2.;
    z *= mat2(.5,.5,-.5,.5);

    for (int n=0;n&lt;=1;n++){
        // modulo(int) doesn't seem to exist, two loops
        // seems to be the cleanest way to do this.
        for (int m=0;m&lt;=1;m++){
            color += three_birds(z*2.+2.,m+1,m==1);
            z *= mat2(0,1,-1,0);
        }
    }
    return color;
}
vec3 color(vec2 z) {
    return vec3(center_tile(z+.5));
}"&gt;&lt;/div&gt;

&lt;p&gt;Next, the corner tiles. They're pretty fiddly, because they have two color schemes. I'm not sure there's any way to talk through the code that will make it more clear, so I'm going to show it as-is. It stamps two three-bird squares, and four individual birds to make up the other half.  &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 corner_tile(vec2 z,bool type){
    z = z.yx;
    z = z*4.-2.;
    int t = int(type);
    vec3 color = vec3(0);
    z *= mat2(.5,.5,-.5,.5);
    if ( t == 1 )
        z *= mat2(0,1,-1,0);

    color += three_birds(z*2.+2.,1+t,0+t ==1);
    z *= mat2(0,1,-1,0);
    color += three_birds(z*2.+2.,2-t,1-t ==1);
    z *= mat2(0,1,-1,0) * mat2(1,1,-1,1);
    color = mix(color,colors(0,true),bird(z));
    z *= mat2(0,-1,1,0);
    color = mix(color,colors(2-t,true),bird(z));
    z *= mat2(0,-1,1,0);
    color = mix(color,colors(1+t,true),
                bird(z+vec2(0.,-4.)));
    z *= mat2(0,-1,1,0);
    color = mix(color,colors(2,false),
                bird(z+vec2(0.,-4.)));
    return vec3(color);
}

vec3 color(vec2 z) {
    return vec3(corner_tile(z+.5,true));
}"&gt;&lt;/div&gt;

&lt;p&gt;Now the corner tiles can slot into our big square. Notice that the corner tiles on the bottom half need to be rotated 180 degrees around, compared to the top half. The entire print actually has 180 degree symmetry, so we can exploit this to create a copy of the entire top half on the bottom by modifying the coordinate system &lt;em&gt;before&lt;/em&gt; we draw anything.&lt;/p&gt;
&lt;div class="codeAndCanvas" literate
 data="vec3 color(vec2 z) {
    // 180 degree rotational symmetry:
    if (z.y &lt; 0.) z=-z; 
    // The lower half is a 180-degree rotated copy
    z = (z+1.)*.75; 
    vec2 a_z = .75-abs(z-.75);
    vec2 scale = scale_f(a_z);
    if (scale.x == scale.y) {
        if (scale.x == 2.)// Center square
              return center_tile(z*2.-1.);
        else // 'Corner' squares
            return corner_tile(mod(z*scale,1.),z.x&gt;1.); 
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return vec3(0,1,0);
    } else { //scale.x &gt; scale.y
        // Left and right
        return vec3(1,1,0); 
    }
}"&gt;&lt;/div&gt;

&lt;p&gt;On the sides, instead of using a square tile, we use a rectangular one consisting of two three-bird tiles. As usual, we fill in the immediate neighbors around the edge. &lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 side_tiles(vec2 z,int colStart,bool cycleDir){
    z = -z*4. + vec2(6,2);
    vec3 col = three_birds(z,colStart,cycleDir);
    vec3 tile2 = three_birds(z*mat2(0,1,-1,0)+vec2(0,4)
,1+colStart,cycleDir);
    col = max(vec3(0.),col - tile2)+tile2;

    // fill in around the edge
    // Left and right
    col = mix(col, colors(2+colStart,cycleDir),
                   bird(z*mat2(0,-1,-1,0)-vec2(0,4)));
    col = mix(col, colors(  colStart,cycleDir),
                   bird(z*mat2(0,1,1,0)-vec2(0,8)));

    // Big top bird
    col = mix(col,colors(1+colStart,cycleDir),
                  bird((z-2.)*mat2(-.5,0,0,.5)+vec2(0.,-2.)));
    // Small bottom birds.
    z.x = mod(z.x-2.,4.)+2.;
    col = mix(col,colors(colStart,cycleDir),
                  bird((z-2.)*mat2(1,1,-1,1)+vec2(2.,6.)));
    col = mix(col,colors(2+colStart,cycleDir),
                  bird((z+vec2(-2,2))*mat2(1,-1,1,1)-2.));
    return col;
}

vec3 color(vec2 z) {
    return vec3(side_tiles(z*2.+1.,1,true));
}"&gt;&lt;/div&gt;

&lt;p&gt;Now we can drop the side tiles into our big square, and out pops the square limit!&lt;/p&gt;
&lt;div class="codeAndCanvas" literate data="vec3 color(vec2 z) {
    if (z.y &lt; 0.) z=-z; 
    z = (z+1.)*.75; 
    vec2 a_z = .75-abs(z-.75);
    vec2 scale = scale_f(a_z);
    if (scale.x == scale.y) {
        if (scale.x == 2.)// Center square
              return center_tile(z*2.-1.);
        else // 'Corner' squares
            return corner_tile(mod(z*scale,1.),z.x&gt;1.); 
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return side_tiles(mod(z*scale.y,2.),0,false);
    } else { //scale.x &gt; scale.y
        // Left and right
        // Rotate around so the right-hand side is correct:
        if (z.x &gt; 1.) z = -z;
        z = vec2(z.y,-z.x); // 90 degree rotation
        return side_tiles(mod(z*scale.x,2.),1,true);
    }
    return vec3(0);
}"&gt;&lt;/div&gt;

&lt;p&gt;Feel free to play with the complete source code &lt;a href="http://roy.red/editor/#/shaders/square limit-5.frag"&gt;in the editor&lt;/a&gt;. One thing to try changing is the motif- there are probably some more interesting ones! &lt;/p&gt;
&lt;div class="codeAndCanvas" literate  override="bird_shape" pre="vec3 sq_limit(vec2 z){
    if (z.y &lt; 0.) z=-z; z = (z+1.)*.75; 
    vec2 a_z = .75-abs(z-.75), scale = scale_f(a_z);
    if (scale.x == scale.y) {
        if (scale.x == 2.) return center_tile(z*2.-1.);
        else return corner_tile(mod(z*scale,1.),z.x&gt;1.); 
    } else if (scale.x &lt; scale.y){
        // Top and bottom
        return side_tiles(mod(z*scale.y,2.),0,false);
    } else { //scale.x &gt; scale.y
        if (z.x &gt; 1.) z = -z;
        z = vec2(z.y,-z.x); // 90 degree rotation
        return side_tiles(mod(z*scale.x,2.),1,true);
    }
}" data="float bird_shape(vec2 z){
    return 10.*(z.y+sin(u_time*3.)*min(0.,abs(z.x+.5)-.5)+2.);
}
vec3 color(vec2 z) {
    return sq_limit(z);
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;And a bonus: this method can easily be adjusted slightly to produce an analog of another Escher print, "Smaller and Smaller". Check out the source code in the editor &lt;a href="http://roy.red/editor/#/shaders/smaller-and-smaller-4.frag"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img style="" width="70%" src="http://roy.red/images/smaller.gif"/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Infinite Regression: Many Pictures From One Function</title><link href="http://roy.red/infinite-regression-.html" rel="alternate"></link><published>2016-07-20T20:15:16-07:00</published><updated>2016-07-20T20:15:16-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-07-20:infinite-regression-.html</id><summary type="html">&lt;p&gt;&lt;a href="http://roy.red/images/regular-division-of-the-plane-vi.jpg"&gt;&lt;img style="float: right;" width="200" src="http://roy.red/images/regular-division-of-the-plane-vi.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was interested in trying to imitate Escher's image, "Regular Division of the Plane IV", which depicts an infinite regression of tiles towards the edge. In doing so, I realized I'd re-written a function I'd seen elsewhere- in &lt;a href="http://www.gamedev.net/topic/590070-glsl-droste"&gt;generating Droste images&lt;/a&gt;- but hadn't looked at closely to understand what it could be used for. It's actually quite powerful and can be used to explore several of Escher's prints! So in this post I am going to play with this function and show how you can manipulate it to generate interesting scaling tilings, as well as a square Droste image (&lt;a href="/droste-.html"&gt;see previous&lt;/a&gt;). As usual there's an (over?)abundance of live code you can fiddle with. The code is GLSL. If GLSL is new to you, take a peek at the &lt;a href="https://thebookofshaders.com/"&gt;Book of Shaders&lt;/a&gt;; the editor will look familiar because I've borrowed it. &lt;/p&gt;
&lt;p&gt;The equation is extremely simple:&lt;/p&gt;
&lt;div class="math"&gt;$$f(x) = 2^{\lfloor \log_2{x}\rfloor}$$&lt;/div&gt;
&lt;p&gt;It turns out it has the exact property we need to draw this sort of image. It's plotted below; &lt;a href="https://www.desmos.com/calculator/4umgsbyrnk"&gt;see also in Desmos&lt;/a&gt;. It builds a staircase that grows a lot like &lt;span class="math"&gt;\(y = x\)&lt;/span&gt;, except that it has discrete jumps at every integer power of two. It also preserves some of the &lt;em&gt;dilational symmetry&lt;/em&gt; of &lt;span class="math"&gt;\(y=x\)&lt;/span&gt;: you can scale the whole thing by a power of two and you get the same plot. Ignoring the coloring, an extension of Escher's print across the whole half-plane would have the same exact symmetry.&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="float plot(vec2 st, float y){
  return  smoothstep( y-0.02, y, st.y) - 
          smoothstep( y, y+0.02, st.y);
}
float function(float x){
    return exp2(floor(log2(x)));
}
vec3 color(vec2 z) {
    z = (z+1.)*vec2(2.,1.02);
    return vec3(.9-plot(z,function(z.x)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Between &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; and &lt;span class="math"&gt;\(1.0\)&lt;/span&gt;, &lt;span class="math"&gt;\(f(x) = 0.5\)&lt;/span&gt;, and so forth, for adjacent powers of two:&lt;/p&gt;
&lt;div class="math"&gt;$$f(x) = 2^{n} \{ 2^n \leq x &amp;lt; 2^{n+1}\}$$&lt;/div&gt;
&lt;p&gt;This is exactly what we need. If you go back and look at the Escher print, there's a series of rows of tiles; each row is exactly half as tall as the one above, and the tiles within it are half as big. &lt;/p&gt;
&lt;p&gt;To start with, we need lots of copies of our image. Here a circle radius &lt;span class="math"&gt;\(0.5\)&lt;/span&gt; is used to tile the plane.&lt;/p&gt;
&lt;div  style='clear:right' class="codeAndCanvas" data="float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    z += 1.;
    // fract == modulo 1.0
    return vec3(circle(fract(z)));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;We then use &lt;span class="math"&gt;\(f(z.x)\)&lt;/span&gt; as a scaling factor, and out pops the Escher-type tiling that I was interested in at the beginning! Notice how in this picture, each "column" of circles lines up with a "step" of the plot of &lt;span class="math"&gt;\(f\)&lt;/span&gt; above.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="float f(float x){
    return exp2(floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    z += 1.;
    float scale = f(z.x);
    z /= scale;
    return vec3(circle(fract(z)));
}"&gt;&lt;/div&gt;

&lt;p&gt;But once we've got this function, we can use it to draw more things! For instance, something reminiscent of Escher's &lt;a href="http://www.wikiart.org/en/m-c-escher/smaller-smaller"&gt;Smaller and Smaller&lt;/a&gt;. Instead of dividing by &lt;code&gt;scale&lt;/code&gt;, we multiply by the reciprocal (multiplication is faster). The input to &lt;span class="math"&gt;\(f\)&lt;/span&gt; is calculated as the larger of &lt;span class="math"&gt;\(\left|x\right|\)&lt;/span&gt; and &lt;span class="math"&gt;\(\left|y\right|\)&lt;/span&gt; which produces a characteristic square pattern. The mathematics of &lt;em&gt;that&lt;/em&gt; is either fiddly or obvious, depending on whether you've seen it before, so I'm going to skip over the derivation. &lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="//'Smaller and Smaller'
float f(float x){
    return exp2(-floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    vec2 a_z = abs(z);
    float scale = f(max(a_z.x,a_z.y));
    return vec3(circle(fract(z*scale)));
}"&gt;&lt;/div&gt;

&lt;p&gt;Looking at this, I saw the obvious similarity to Droste images; it is a Droste image, except that we've got extra copies of the original. "Extra copies" is a good problem to have, because we're just a constant or two away from a classic square Droste picture. &lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x){
    return exp2(-floor(log2(x))-2.); // here's the change
}

vec3 color(vec2 z) { 
    vec2 a_z = abs(z);
    float scale = f(max(a_z.x,a_z.y));
    return texture2D(u_tex0,z*scale+0.5).xyz;
}"&gt;&lt;/div&gt;

&lt;p&gt;And now we can apply Escher's twist that &lt;a href="/droste-.html"&gt;I implemented previously&lt;/a&gt;. This time though, we don't need to use any modulo function, since we already have our infinitely nesting copies. This makes the transformation nearly a one-liner.&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x){
    return exp2(-floor(log2(x)));
}
vec3 color(vec2 z) { 
    float angle = atan(log(2.)/(2.0*PI));
    z = cExp(cDiv(cLog(z), cExp(vec2(0,angle))*cos(angle))); 
    vec2 a_z = abs(z);
    z *= f(max(a_z.x,a_z.y)*2.);
    return texture2D(u_tex0,z*.5+0.5).xyz;
}"&gt;&lt;/div&gt;

&lt;p&gt;The obvious generalization to &lt;span class="math"&gt;\(f\)&lt;/span&gt; is to allow an arbitrary exponent, and it turns out it also generalizes our Droste too, adjusting how deep each copy is created. &lt;/p&gt;
&lt;div class="math"&gt;$$f(x,n) = n^{\lfloor \log_n{x}\rfloor}$$&lt;/div&gt;
&lt;div style='clear:right' class="codeAndCanvas" data-textures="/images/labyrinth.jpg" data="float f(float x,float n){
    return pow(n,-floor(log(x)/log(n)));
}
vec3 color(vec2 z) {
    float ratio = 5.264;
    float angle = atan(log(ratio)/(2.0*PI));
    z = cExp(cDiv(cLog(z), cExp(vec2(0,angle))*cos(angle)));
    vec2 a_z = abs(z);
    z *= f(max(a_z.x,a_z.y)*2.,ratio);
    return texture2D(u_tex0,z/ratio+.5).xyz;
}"&gt;&lt;/div&gt;

&lt;p&gt;And with some more constants and an adjustment, there's a simple version of Escher's &lt;a href="http://www.wikiart.org/en/m-c-escher/square-limit?utm_source=returned"&gt;Square Limit&lt;/a&gt; hidden inside here as well!&lt;/p&gt;
&lt;div style='clear:right' class="codeAndCanvas" data="float f(float x){
    return exp2(-floor(log2(x)));
}
float circle(vec2 z){
    return 1.-length(2.*z-1.);
}
vec3 color(vec2 z) { 
    // Arrived at by motivated guesswork
    z = (z+1.)*.75;
    vec2 a_z = .75-abs(z-.75);
    return vec3(circle(fract(z*f(min(a_z.x,a_z.y)))));
}"&gt;&lt;/div&gt;

&lt;p&gt;That's all for now! If you want to have some more fun with Droste images, check out my previous post on &lt;a href="/fractal-droste-images-.html"&gt;fractally-distorted drostes&lt;/a&gt;. Or perhaps take a leap into the &lt;a href="/slitscan-.html"&gt;Time Tunnel&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;See also:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;David Bailey's &lt;a href="http://www.tess-elation.co.uk/self-similar-tessellations"&gt;World of Tessellations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://shashi.github.io/ijulia-notebooks/funcgeo/"&gt;Functional Geometry in Julia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary></entry><entry><title>Fun with interference patterns</title><link href="http://roy.red/interference-.html" rel="alternate"></link><published>2016-05-04T21:04:56-07:00</published><updated>2016-05-04T21:04:56-07:00</updated><author><name>Roy Wiggins</name></author><id>tag:roy.red,2016-05-04:interference-.html</id><summary type="html">&lt;p&gt;Ordinary trigonometric functions can produce really interesting, structured patterns if you use sufficiently large numbers. There's nothing fancy happening here, but at different scales and with different constants, the result can change quite drastically. Try zooming in (&lt;code&gt;z = z * 0.01&lt;/code&gt; for instance) and you'll see that it's just bands of white and black. It's only when you zoom out that creeping bands moving in crazy directions appear.&lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 z) {
    z = z * 1.;
    float r=length(z);
    return vec3(sin(cos(r)*r*(u_time+1000.)*10.0));
}"&gt;&lt;/div&gt;

&lt;p&gt;I'm fairly sure this is a straightforward consequence of interference. The square grid of pixels is sampling the underlying equation at regular intervals. The result is a kind of &lt;a href="https://en.wikipedia.org/wiki/Moir%C3%A9_pattern"&gt;moiré pattern&lt;/a&gt;. For photography and graphics applications aliasing is Bad News, but you can harness it to produce interesting patterns. &lt;/p&gt;
&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;Anyway, math aside, you can pretty much just start messing with constants and mushing trigonometric functions together here and see what happens. It inherits some of the rotational symmetry of the underlying pattern, so we end up with something that isn't completely mush. Plugging the time variable into a periodic function like &lt;code&gt;sin&lt;/code&gt; lets us quite easily find interesting loops, ripe for the giffing. &lt;/p&gt;
&lt;div class="codeAndCanvas" data="vec3 color(vec2 pt) {
    pt = pt * 1.6;
    float r = length(pt);
    float stime = 4.*sin(u_time * 2. * PI)+100.;
    return vec3(r+cos(cos(r*r*100.)*stime));
}"&gt;&lt;/div&gt;

&lt;div style='clear:right'&gt;&lt;/div&gt;

&lt;p&gt;My current "fancy" way to gif something is to render it in &lt;a href="https://syntopia.github.io/Fragmentarium/index.html"&gt;Fragmentarium&lt;/a&gt; and take the resulting pngs and run them through &lt;a href="https://www.imagemagick.org/script/index.php"&gt;ImageMagick&lt;/a&gt;'s &lt;code&gt;convert&lt;/code&gt; utility. This is a bit fiddly, so often I just use my favorite program: &lt;a href="http://blog.bahraniapps.com/gifcam/"&gt;GifCam&lt;/a&gt;! It's a tiny utility that records gifs directly off your screen. It certainly won't produce the best, smallest, lowest-artifact gif, but it's easy to use and the results aren't half bad!&lt;/p&gt;
&lt;p&gt;&lt;img width="250" src="/images/interference-1.gif"/&gt;
&lt;img width="250" src="/images/circles_m.gif"/&gt;
&lt;img width="250" src="/images/mandala2.gif"/&gt;&lt;/p&gt;</summary></entry></feed>