<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/style.min.css">
    <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/extra.css">
  <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://roy.red/theme/stylesheet/font-awesome.min.css">
    <link type="text/css" rel="stylesheet" href="http://roy.red/theme/stylesheet/glslEditor.css">
    <script type="application/javascript" src="http://roy.red/theme/script/glslEditor.js"></script>
  <script type="text/javascript" src="http://roy.red/theme/script/GlslCanvas.js"></script>

    <link href="http://roy.red/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Roy.red Atom">



  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

<meta name="author" content="Roy Wiggins" />
<meta name="description" content="How to fold space into a Koch snowflake." />
<meta name="keywords" content="glsl">
<meta property="og:site_name" content="Roy.red"/>
<meta property="og:title" content="Kaleidoscopic Fractals: Folding the Koch Snowflake"/>
<meta property="og:description" content="How to fold space into a Koch snowflake."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="http://roy.red/folding-the-koch-snowflake-.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-01-03 17:34:06-08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://roy.red/author/roy-wiggins.html">
<meta property="article:section" content="glsl"/>
<meta property="article:tag" content="glsl"/>
<meta property="og:image" content="">
  <title>Roy.red &ndash; Kaleidoscopic Fractals: Folding the Koch Snowflake</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://roy.red">
        <img src="http://roy.red/theme/img/profile.png" alt="Roy's Blog" title="Roy's Blog">
      </a>
      <h1><a href="http://roy.red">Roy's Blog</a></h1>
      <p></p>
      <nav>
        <ul class="list">
          <li><a href="http://roy.red/pages/resources-.html#resources">Resources</a></li>
          <li><a href="http://roy.red/pages/resume-.html#resume">Resume</a></li>
          <li><a href="https://twitter.com/RoyWiggins" target="_blank">@RoyWiggins</a></li>
          <li><a href="./editor" target="_blank">Editor</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-@RoyWiggins" href="https://twitter.com/RoyWiggins" target="_blank"><i class="fa fa-@RoyWiggins"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>

<article>
  <header>
    <h1 id="folding-the-koch-snowflake">Kaleidoscopic Fractals: Folding the Koch Snowflake</h1>
    <p>Posted on Tue 03 January 2017 in <a href="http://roy.red/category/glsl.html">glsl</a></p>
  </header>
  <div>
    <p>I came across a shader that generated a <a href="https://www.shadertoy.com/view/XdcGzH">very pretty version</a> of the Koch snowflake](https://en.wikipedia.org/wiki/Koch_snowflake). I realized that after stepping through the code that the Koch snowflake is a good, simple example of generating fractals with folds. The code here is in the form of fragment shaders. For a shader primer, check out the <a href="http://thebookofshaders.com/">Book of Shaders</a>. The important thing is that to write a fragment shader, you build a function that takes a location (in our case, of a pixel) and returns a color. All the code here is "live", though changes you make in each box will not cascade down to the subsequent ones.</p>
<p><a href="http://acko.net/blog/how-to-fold-a-julia-fractal/"><img style="float: right;" width="300" src="http://roy.red/images/julia-iter.gif"/></a></p>
<p>Generating the Koch curve this way is probably among the simplest examples of how fractals can be thought of as a repeated crumpling of space. The animation to the right is borrowed from <a href="http://acko.net/blog/how-to-fold-a-julia-fractal/">a presentation</a> by Steven Wittens that ably demonstrates this with a Julia fractal: squishing, translating and folding space progressively crumples up the boundary of the unit circle.</p>
<p>For the Koch curve, we need a different sort of fold. It's easiest to understand the folding operation visually. I haven't taken the time to justify this formula, but it's just trigonometry. You can adjust the angle to see how it creates a kaleidoscopic effect, reflecting the plane across a line through the origin. </p>
<div style='clear:right'></div>

<div class="codeAndCanvas" literate data="vec2 fold(vec2 p, float ang){
    vec2 n=vec2(cos(-ang),sin(-ang));
    p-=2.*min(0.,dot(p,n))*n;
    return p;
}
vec3 color(vec2 pt) {
    // Adjust the angle of the fold here
    pt=fold(pt,0.284);
    return vec3(10.*sin(10.*pt.x)*sin(10.*pt.y));
}"></div>

<div style='clear:right'></div>

<p>Now we are going to start drawing a line. This formula calculates the distance to a line segment between <span class="math">\((0,0)\)</span> and <span class="math">\((1,0)\)</span>. This is the line we're going to fold up into a Koch curve.</p>
<div class="codeAndCanvas" literate data="float d2hline(vec2 p){
    p.x-=max(0.,min(1.,p.x));
    return length(p)*5.;
}
vec3 color(vec2 pt) {
    pt=pt*2.;
    return vec3(d2hline(pt));
}"></div>

<div style='clear:right'></div>

<p>There are two folds: first, across the angle <span class="math">\(\frac{\pi}{6}\)</span>, and then horizontally. </p>
<div class="codeAndCanvas" literate data="
vec2 koch_fold(vec2 pt) {
    // Fold horizontally
    pt.x = abs(pt.x);
    pt.x-=.5;
    //Fold across PI/6
    pt = fold(pt,PI/6.);
    return pt;
}
vec3 color(vec2 pt) {
    pt*=2.;
    pt=koch_fold(pt);
    return vec3(d2hline(pt));
}"></div>

<div style='clear:right'></div>

<p>We can iterate by moving and scaling the folded line to lie along the original line (from <span class="math">\((0,0)\)</span> to <span class="math">\((0,1)\)</span>) and then folding the line up again.</p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    pt*=2.;
    pt=koch_fold(pt); // Fold again
    // Move it to lie along the (0,1) line
    pt*=3.;
    pt.x-=1.5;
    pt=koch_fold(pt); // Fold once
    return vec3(d2hline(pt));
}"></div>

<div style='clear:right'></div>

<p>And we can iterate this as many times as we'd like. It converges very rapidly, so you only need a handful of folds.</p>
<div class="codeAndCanvas" literate data="vec2 koch_curve(vec2 pt) {
    //Fold and scale a few times
    for(int i=0;i<5;i++){
        pt*=3.;
        pt.x-=1.5;
        pt=koch_fold(pt);
    }
    return pt;
}
vec3 color(vec2 pt) {
    pt = pt*.5+.5;
    pt = koch_curve(pt);
    return vec3(d2hline(pt)/5.);
}"></div>

<div style='clear:right'></div>

<p>And just for fun, we can do two more folds to create two copies of the curve to create the Koch Snowflake. </p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    pt = pt*.7;
    pt -= vec2(.5,.3);
    pt = fold(pt,-2.*PI/3.);
    pt.x += 1.;
    pt = fold(pt,-PI/3.);
    pt = koch_curve(pt);
    return vec3(d2hline(pt)/5.);
}"></div>

<p>A small adjustment and we get another familiar fractal, a Sierpinski triangle, or close enough. I recommend you adjust the number of iterations to get a feel for how it converges.</p>
<div class="codeAndCanvas" literate data="
vec2 tri_fold(vec2 pt) {
    pt = fold(pt,PI/6.);
    pt = fold(pt,-PI/6.);
    return pt;
}
vec2 tri_curve(vec2 pt) {
    for(int i=0;i<7;i++){
        pt*=2.;
        pt.x-=1.;
        pt=tri_fold(pt);
    }
    return pt;
}
vec3 color(vec2 pt) {
    pt -= vec2(-1,.1);
    pt *= .5;
    pt = tri_curve(pt);
    return vec3(d2hline(pt)/7.);
}"></div>

<p>You might have worked this out already: I've been keeping something from you. The real motivation here is to justify a wider class of fractals, dubbed Kaleidoscopic Iterated Function Systems, or KIFS. KIFS are what you get when you start folding and scaling around different axes. A myriad of fractals fall out, and you can see why they're called Kaleidoscopic- for the mirroring folds they're built out of. Here's an example. These reward fiddling: adjust the parameters to get a slightly better sense of how the folds affect the final output. </p>
<div class="codeAndCanvas" literate data="vec2 gen_fold(vec2 pt) {
    pt = fold(pt,-2.9);
    pt = fold(pt,.9);
    pt.y+=sin(u_time)+1.;
    pt = fold(pt,-1.0);
    return pt;
}
vec2 gen_curve(vec2 pt) {
    for(int i=0;i<9;i++){
        pt*=2.;
        pt.x-=1.;
        pt=gen_fold(pt);
    }
    return pt;
}
vec3 color(vec2 pt) {
    pt -= vec2(-0.630,0.000);
    pt *= .8;
    pt = gen_curve(pt);
    return vec3(d2hline(pt)/6.);
}"></div>

<p>Another confession: In truth, we haven't just been building a black and white image. We've been calculating a 2D distance estimator to the fractal. For any point in the plane, the value of our function is an approximation of the distance to the fractal. We can illustrate it by taking the modulo of the value:</p>
<div class="codeAndCanvas" literate data="vec3 color(vec2 pt) {
    pt = pt*.7;
    pt += vec2(.5,0.);
    pt = koch_curve(pt);
    return vec3(mod(d2hline(pt)/70.,1.));
}"></div>

<p>Final confession: this distance estimator? It's not useful. At least, not in 2D. But it's <em>exactly</em> what we need to draw pictures of three-dimensional KIFS fractals. <a href="http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html">Raymarching</a> is a rendering tool that can render pretty much any surface if you have an estimate of the distance to the surface from any point in space. </p>
<p>All we need to adjust is adding some folds that live inside the <span class="math">\(yz\)</span> plane, rather than keeping in the <span class="math">\(xy\)</span> plane. Taking that distance estimate and plugging it into a raymarcher, we get similar 3D fractals! Try adjusting the fold angles to get a sense of the sorts of shapes this is capable of. </p>
<div class="codeAndCanvas" literate override="DE" data="vec3 tri_fold(vec3 pt) {
    pt.xy = fold(pt.xy,PI/3.-cos(u_time)/10.);
    pt.xy = fold(pt.xy,-PI/3.);
    pt.yz = fold(pt.yz,-PI/6.+sin(u_time)/2.);
    pt.yz = fold(pt.yz,PI/6.);
    return pt;
}
vec3 tri_curve(vec3 pt) {
    for(int i=0;i<7;i++){
        pt*=2.;
        pt.x-=2.6;
        pt=tri_fold(pt);
    }
    return pt;
}
float DE(vec3 p){
    p *= .75;
    p.x+=1.5;
    p=tri_curve(p);
    return (length( p*.004 ) - .01);
}
vec3 color(vec2 pt) {
    return simple_raymarch(pt);
}"></div>

<p>You can play with the full source to this fractal <a href="http://roy.red/editor/#/shaders/kifs.frag">here</a>. This is a very simple and unoptimized renderer, and I'm not adept enough at writing raymarchers to tune it perfectly. More sophisticated and well-tuned renderers can draw much prettier pictures! </p>
<p>For more information you should check out my main source for this post, Mikael Hvidtfeldt Christensen's <a href="http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/">series on distance estimated 3D fractals</a>, which covers KIFS and more. His program Fragmentarium comes with a number of KIFS fractals built in, and produces some very pretty results. </p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://roy.red/tag/glsl.html">glsl</a>
    </p>
  </div>
</article>

    <footer>
        <p>&copy; Roy Wiggins </p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Kaleidoscopic Fractals: Folding the Koch Snowflake",
  "headline": "Kaleidoscopic Fractals: Folding the Koch Snowflake",
  "datePublished": "2017-01-03 17:34:06-08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Roy Wiggins",
    "url": "http://roy.red/author/roy-wiggins.html"
  },
  "image": "{{ SITEURL }}/{{ THEME_STATIC_DIR }}/img/profile.png",
  "url": "http://roy.red/folding-the-koch-snowflake-.html",
  "description": "How to fold space into a Koch snowflake."
}
</script>  
  <script type="application/javascript" src="http://roy.red/theme/script/main.js"></script>
</body>
</html>