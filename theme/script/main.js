(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){


var preFunction = "precision mediump float;\n#define GLSLIFY 1\n\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n\nuniform vec2 u_resolution;\n\nuniform vec2 u_mouse;\n\nuniform float u_time;\n\nfloat zoom = 0.5;\n\nvec2 offset = vec2(0.5);\n\nmat3 rotationMatrix3(vec3 v, float angle)\n\n{  float c = cos(radians(angle));\n\n    float s = sin(radians(angle));\n\n    return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\n        (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\n        (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\n        );\n\n}\n\nvec3 radius(vec2 c,float r1, float r2, float angle){\n\n    mat3 m =rotationMatrix3(vec3(0,0,1),angle);\n\n    c = (m * vec3(c,0)).xy;\n\n    return vec3( (smoothstep(r1,r1+.01, c.x) - smoothstep(r2,r2+.01,c.x) ) * \n\n                   (smoothstep(-0.02,-0.01,c.y) - smoothstep(0.01,0.02,c.y) ));\n\n}\n\nvoid addColor(inout vec3 base, vec3 new, vec3 amt){\n\n    base = mix(base,new,amt);\n\n}\n\nvec3 circle(vec2 c, float r){\n\n    return vec3( smoothstep(0.,.01,length(c)-r+0.02)-smoothstep(0.,.01,length(c)-r-0.02));\n\n}\n\nvec3 circles(vec2 z,float r1,float r2){\n\n    vec3 col;\n\n    addColor(col,vec3(0,1,0),radius(z, r1,r2,0.));\n\n    addColor(col,vec3(0,0,1),radius(z, r1,r2,90.));\n\n    addColor(col,vec3(1,1,0),radius(z, r1,r2,180.));\n\n    addColor(col,vec3(1,0,1),radius(z, r1,r2,270.));\n\n    addColor(col,vec3(1,0.5,0.5),circle(z,r1));\n\n    addColor(col,vec3(1,0.5,0.5),circle(z,r2));\n\n    return col;\n\n}\n\nfloat cosh(float val)\n\n{\n\n    float tmp = exp(val);\n\n    float cosH = (tmp + 1.0 / tmp) / 2.0;\n\n    return cosH;\n\n}\n\nfloat tanh(float val)\n\n{\n\n    float tmp = exp(val);\n\n    float tanH = (tmp - 1.0 / tmp) / (tmp + 1.0 / tmp);\n\n    return tanH;\n\n}\n\nfloat sinh(float val)\n\n{\n\n    float tmp = exp(val);\n\n    float sinH = (tmp - 1.0 / tmp) / 2.0;\n\n    return sinH;\n\n}\n\nvec2 cMul(vec2 a, vec2 b) {\n\n    return vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n\n}\n\nvec2 cPower(vec2 z, float n) {\n\n    float r2 = dot(z,z);\n\n    return pow(r2,n/2.0)*vec2(cos(n*atan(z.y,z.x)),sin(n*atan(z.y,z.x)));\n\n}\n\nvec2 cInverse(vec2 a) {\n\n    return  vec2(a.x,-a.y)/dot(a,a);\n\n}\n\nvec2 cDiv(vec2 a, vec2 b) {\n\n    return cMul( a,cInverse(b));\n\n}\n\nvec2 cExp(in vec2 z){\n\n    return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n\n}\n\nvec2 cLog(vec2 a) {\n\n    float b =  atan(a.y,a.x);\n\n    if (b>0.0) b-=2.0*3.1415;\n\n    return vec2(log(length(a)),b);\n\n}\n\nvec2 cSqr(vec2 z) {\n\n    return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y);\n\n}\n\nvec2 cSin(vec2 z) {\n\n    return vec2(sin(z.x)*cosh(z.y), cos(z.x)*sinh(z.y));\n\n}\n\nvec2 cCos(vec2 z) {\n\n    return vec2(cos(z.x)*cosh(z.y), -sin(z.x)*sinh(z.y));\n\n}\n\nvec2 cPower2(vec2 z, vec2 a) {\n\n    return cExp(cMul(cLog(z), a));\n\n}\n\nvec3 hash3( vec2 p ){\n\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\n                   dot(p,vec2(269.5,183.3)), \n\n                   dot(p,vec2(419.2,371.9)) );\n\n    return fract(sin(q)*43758.5453);\n\n}\n\nfloat iqnoise( in vec2 x, float u, float v ){\n\n//https://www.shadertoy.com/view/Xd23Dh\r\n    vec2 p = floor(x);\n\n    vec2 f = fract(x);\n\n    float k = 1.0+63.0*pow(1.0-v,4.0);\n\n    float va = 0.0;\n\n    float wt = 0.0;\n\n    for( int j=-2; j<=2; j++ )\n\n    for( int i=-2; i<=2; i++ )\n\n    {\n\n        vec2 g = vec2( float(i),float(j) );\n\n        vec3 o = hash3( p + g )*vec3(u,u,1.0);\n\n        vec2 r = g - f + o.xy;\n\n        float d = dot(r,r);\n\n        float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\n        va += o.z*ww;\n\n        wt += ww;\n\n    }\n\n    return va/wt;\n\n}\n\nvec3 hsv2rgb(vec3 c)\n\n{\n\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\n}\n\nfloat sphere( vec3 p, float radius )\n\n{\n\n    return length( p ) - radius;\n\n}\n\n \n\n//-----------------------------------------------------------------------------------------------\r\n// The map function is the function that defines our scene.\r\n\nfloat map( vec3 p )\n\n{    \n\n    return sphere( p, 1.0 );\n\n}\n\n \n\nvec3 getNormal( vec3 p )\n\n{\n\n    vec3 e = vec3( 0.001, 0.00, 0.00 );\n\n    \n\n    float deltaX = map( p + e.xyy ) - map( p - e.xyy );\n\n    float deltaY = map( p + e.yxy ) - map( p - e.yxy );\n\n    float deltaZ = map( p + e.yyx ) - map( p - e.yyx );\n\n    \n\n    return normalize( vec3( deltaX, deltaY, deltaZ ) );\n\n}\n\n \n\nfloat trace( vec3 origin, vec3 direction, out vec3 p )\n\n{\n\n    float totalDistanceTraveled = 0.0;\n\n \n\n    for( int i=0; i <170; ++i)\n\n    {\n\n        // Here we march along our ray and store the new point\r\n        // on the ray in the \"p\" variable.\r\n        p = origin + direction * totalDistanceTraveled;\n\n \n\n        // \"distanceFromPointOnRayToClosestObjectInScene\" is the \r\n        // distance traveled from our current position along \r\n        // our ray to the closest point on any object\r\n        // in our scene.  Remember that we use \"totalDistanceTraveled\"\r\n        // to calculate the new point along our ray.  We could just\r\n        // increment the \"totalDistanceTraveled\" by some fixed amount.\r\n        // However we can improve the performance of our shader by\r\n        // incrementing the \"totalDistanceTraveled\" by the distance\r\n        // returned by our map function.  This works because our map function\r\n        // simply returns the distance from some arbitrary point \"p\" to the closest\r\n        // point on any geometric object in our scene.  We know we are probably about \r\n        // to intersect with an object in the scene if the resulting distance is very small.\r\n        float distanceFromPointOnRayToClosestObjectInScene = map( p );\n\n        totalDistanceTraveled += distanceFromPointOnRayToClosestObjectInScene;\n\n \n\n        // If our last step was very small, that means we are probably very close to\r\n        // intersecting an object in our scene.  Therefore we can improve our performance\r\n        // by just pretending that we hit the object and exiting early.\r\n        if( distanceFromPointOnRayToClosestObjectInScene < 0.0001 )\n\n        {\n\n            break;\n\n        }\n\n \n\n        // If on the other hand our totalDistanceTraveled is a really huge distance,\r\n        // we are probably marching along a ray pointing to empty space.  Again,\r\n        // to improve performance,  we should just exit early.  We really only want\r\n        // the trace function to tell us how far we have to march along our ray\r\n        // to intersect with some geometry.  In this case we won't intersect with any\r\n        // geometry so we will set our totalDistanceTraveled to 0.00. \r\n        if( totalDistanceTraveled > 10000.0 )\n\n        {\n\n            totalDistanceTraveled = 0.0000;\n\n            break;\n\n        }\n\n    }\n\n \n\n    return totalDistanceTraveled;\n\n}\n\n \n\n//-----------------------------------------------------------------------------------------------\r\n// Standard Blinn lighting model.\r\n// This model computes the diffuse and specular components of the final surface color.\r\nvec3 calculateLighting(vec3 pointOnSurface, vec3 surfaceNormal, vec3 lightPosition, vec3 cameraPosition,vec3 diff)\n\n{\n\n    vec3 fromPointToLight = normalize(lightPosition - pointOnSurface);\n\n    float diffuseStrength = clamp( dot( surfaceNormal, fromPointToLight ), 0.0, 1.0 );\n\n    \n\n    vec3 diffuseColor = diffuseStrength * diff;\n\n    vec3 reflectedLightVector = normalize( reflect( -fromPointToLight, surfaceNormal ) );\n\n    \n\n    vec3 fromPointToCamera = normalize( cameraPosition - pointOnSurface );\n\n    float specularStrength = pow( clamp( dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0 ), 10.0 );\n\n \n\n    // Ensure that there is no specular lighting when there is no diffuse lighting.\r\n    specularStrength = min( diffuseStrength, specularStrength );\n\n    vec3 specularColor = specularStrength * vec3( 1.0 );\n\n    \n\n    vec3 finalColor = diffuseColor;// + specularColor; \r\n \n\n    return finalColor;\n\n}\n\nvec2 projectToSphere(vec2 uv, out float distanceToClosestPointInScene){\n\n    vec3 cameraPosition = vec3(0.,-10.026,10.260);\n\n    \n\n    // We will need to shoot a ray from our camera's position through each pixel.  To do this,\r\n    // we will exploit the uv variable we calculated earlier, which describes the pixel we are\r\n    // currently rendering, and make that our direction vector.\r\n    vec3 cameraDirection = normalize( vec3( uv.x, uv.y, -10.0) );\n\n    cameraDirection = cameraDirection * rotationMatrix3(vec3(1,0,0),44.);\n\n    vec3 pointOnSurface;\n\n    distanceToClosestPointInScene = trace( cameraPosition, cameraDirection, pointOnSurface );\n\n    vec2 projected = pointOnSurface.xy / (1.-pointOnSurface.z);\n\n    return projected;\n\n}";

var glslCanvases = [];
var glslEditors = [];
var glslGraphs = [];
function loadGlslElements() {

var postFunction = "\n\
void main(){\n\
    vec2 st = (gl_FragCoord.xy/u_resolution.xy)-offset;\n\
    st.x *= u_resolution.x/u_resolution.y;\n\
    gl_FragColor = vec4(color(st/zoom),1.0);\n\
}"
    // Load single Shaders
    var canvas = document.getElementsByClassName("canvas");
    for (var i = 0; i < canvas.length; i++){
        glslCanvases.push(new GlslCanvas(canvas[i]));
    } 

    // parse EDITORS
    var ccList = document.querySelectorAll(".codeAndCanvas");
    for(var i = 0; i < ccList.length; i++){
        if (ccList[i].hasAttribute("data")){
            var srcFile = ccList[i].getAttribute("data");
            var editor = new GlslEditor(ccList[i], { canvas_size: 250, canvas_follow: true, tooltips: true, exportIcon: true, frag_header: preFunction,frag_footer: postFunction});
            editor.open(srcFile);
            glslEditors.push(editor);
        }
    }

    // parse GRAPHS
    var sfList = document.querySelectorAll(".simpleFunction");
    for(var i = 0; i < sfList.length; i++){
        if (sfList[i].hasAttribute("data")){
            var srcFile = sfList[i].getAttribute("data");
            glslGraphs.push(new GlslEditor(sfList[i], { canvas_width: 800, lineNumbers: false, canvas_height: 250, frag_header: preFunction, frag_footer: postFunction, tooltips: true }).open(srcFile));
        }
    }    
}
loadGlslElements();
},{}]},{},[1]);
